---
title: "comp_density"
author: "Christian Mercado"
date: "3/28/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)

#load packages
library(tidyverse)
library(mgcv)
library(gratia)
library(ggrepel)
library(corrplot)
library(GGally)
library(mgcViz)
source('12.gam_fns.R')

hab_loc_codes <- read_csv('data/habtypes.csv')
hab_loc_codes <- hab_loc_codes %>% select(SETTING_ID, habclass, locationcode)

#load data
bai.train <- readRDS('data/bai.train.4_21_22.rds')
bai.train <- left_join(bai.train, hab_loc_codes, by = "SETTING_ID")

bai.size <- bai.train %>% 
  select(stand, MEASUREMENT_NO, PLOT, unique_tree_id, 
         bai, DIAMETER, treeba, log.diam, log.bai, grwth.yr) %>% 
  filter(bai != 0)

bai.site <- bai.train %>% 
  select(stand, MEASUREMENT_NO, PLOT, unique_tree_id, 
         bai, DIAMETER, treeba, log.diam, log.bai, 
         grwth.yr, mean_si, aspect_deg, 
         heatload, slope_deg, elev_m, NF) %>% 
  mutate(slope_pct = tan(slope_deg*(pi/180))*100, 
         asp_sin = sin(aspect_deg*(pi/180)), 
         asp_cos = cos(aspect_deg*(pi/180))) %>%
  mutate(sl_asp_sin = asp_sin*slope_pct, 
         sl_asp_cos = asp_cos*slope_pct, 
         asp.trasp = trasp(aspect_deg)) %>% 
  filter(bai != 0)

bai.dcomp <- bai.train %>% 
  select(stand, MEASUREMENT_NO, PLOT, unique_tree_id, 
         bai, DIAMETER, treeba, log.diam, log.bai, grwth.yr, mean_si, aspect_deg, 
         heatload, slope_deg, elev_m, NF, CROWN_RATIO, tpa.pl.all, tpa.pl.cutoff,
         ba.pl, bal.pl, ccf.pl, qmd.pl.all, qmd.pl.cutoff, dq.pl.all, dq.pl.cutoff, tpa.cl.all, tpa.pl.cutoff,
         ba.cl, ccf.cl, bal.cl, dq.cl.all, dq.cl.cutoff, HabType, habclass,
         locationcode) %>% 
  mutate(slope_pct = tan(slope_deg*(pi/180))*100, 
         asp_sin = sin(aspect_deg*(pi/180)),
         asp_cos = cos(aspect_deg*(pi/180))) %>%
  mutate(sl_asp_sin = asp_sin*slope_pct, 
         sl_asp_cos = asp_cos*slope_pct, 
         asp.trasp = trasp(aspect_deg), 
         HabType = as.factor(HabType),
         cr = CROWN_RATIO/100,
         bal.pl.ratio = bal.pl/ba.pl) %>% 
  filter(bai != 0)


rmse.conc <- function(x){
  rmse.df <- my.rmse.2(x)[[2]]
  concurve <- concurvity(x)
  concurve.test <- ifelse(any(concurve[3,]>=0.8), 'high-concurvity', 'low-concurvity') 
  rmse.conc.ls <- list('rmse.df' = rmse.df, 
                       'concurvity' = concurve, 
                       'concurvity.test' = concurve.test)
  
  return(rmse.conc.ls)
}

```


NOTES: CCF is stand crown competition factor in FVS model
: Habitat type is factored into crown competition factor via habitat calss
: dbh^2 term is modified by location class


NOTE: Added QMD as a plot-level metric. Transformed BAL.PL to a ratio, now it's interpretation is what ratio of BA in a plot is larger than the subject tree. This hopefully will clear up co-linearity between BAL and BA.

```{r corrmat}

compd.tree <- bai.dcomp %>% select(cr, bal.pl.ratio, dq.pl.all)
compd.plot <- bai.dcomp %>% select(tpa.pl.all, qmd.pl.all, ba.pl, ccf.pl)
compd.all <- bai.dcomp %>% select(cr, bal.pl.ratio, qmd.pl.all, dq.pl.all, tpa.pl.all, ba.pl, ccf.pl)

#dcomp.pl <- bai.dcomp %>% select(log.bai, CROWN_RATIO, tpa.pl.all, tpa.pl.cutoff, ba.pl, bal.pl, ccf.pl, dq.pl.all, dq.pl.cutoff, HabType)
#dcomp.cl <- bai.dcomp %>% select(log.bai, CROWN_RATIO, tpa.cl.all, tpa.pl.cutoff, ba.cl, ccf.cl, bal.cl, dq.cl.all, dq.cl.cutoff, HabType)

#dcomp.pl1 <- bai.dcomp %>% select(tpa.pl.all, ba.pl, ccf.pl)

ggpairs(compd.tree)
ggpairs(compd.plot)
ggpairs(compd.all)

#### SHOULD NOT USE CCF AND BA IN THE SAME MODEL DUE TO HIGH CORRELATION
#### TPA AND DQRATIO HIGH CORRELATION
#### CCF AND BAL HIGH CORR


####### UPDATE
### HIGH CORRS: BA-CR, CCF-CR, BA-QMD, CCF-QMD, TPA-DQ, BA-CCF

####### UPDATE AGAIN - also rounding up to 0.7
### HIGH CORRS UPDATE: TPA-DQ, BA-QMD, CCF-BA

```

```{r 1 tree-level variable selection - site first}
## Begin with tree vars - all included - adding to model with site vars
compd1 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(slope_pct) + s(cr, k = 9) + s(bal.pl.ratio) + s(dq.pl.all), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#cr and bal
compd2 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(slope_pct) + s(cr, k = 9) + s(bal.pl.ratio), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#cr and dq
compd3 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(slope_pct) + s(cr, k = 9) + s(dq.pl.all), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#bal and dq
compd4 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(slope_pct) + s(dq.pl.all) + s(bal.pl.ratio), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

### INDIVIDUALS
#cr
compd.cr <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(slope_pct) + s(cr, k = 9), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#bal
compd.bal <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(slope_pct) + s(bal.pl.ratio), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#dq
compd.dq <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(slope_pct) + s(bal.pl.ratio), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')


compdlist.full <- list('full compd' = compd1, 'cr-bal' = compd2, 'cr-dq' = compd3, 'bal-dq' = compd4)

compdlist.ind <- list('cr' = compd.cr, 'bal' = compd.bal, 'dq' = compd.dq)


concurvity(compd.bal, full = T)

```

```{r 2 variable selection - no site}
## Begin with tree vars - all included - adding to model with site vars
nosite.compd1 <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(bal.pl.ratio) + s(dq.pl.all), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#cr and bal
nosite.compd2 <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(bal.pl.ratio), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#cr and dq
nosite.compd3 <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(dq.pl.all), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#bal and dq
nosite.compd4 <- gam(bai~s(DIAMETER) + s(dq.pl.all) + s(bal.pl.ratio), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

### INDIVIDUALS
#cr
nosite.compd.cr <- gam(bai~s(DIAMETER) + s(cr, k = 9), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#bal
nosite.compd.bal <- gam(bai~s(DIAMETER) + s(bal.pl.ratio), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#dq
nosite.compd.dq <- gam(bai~s(DIAMETER) + s(dq.pl.all), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')


nosite.compdlist.full <- list('full compd' = nosite.compd1, 'cr-bal' = nosite.compd2, 'cr-dq' = nosite.compd3, 'bal-dq' = nosite.compd4)

nosite.compdlist.ind <- list('cr' = nosite.compd.cr, 'bal' = nosite.compd.bal, 'dq' = nosite.compd.dq)


```

```{r 3 plot vars - no site first - building on full compd for now}
### Add plot-level vars
#### SHOULD NOT USE CCF AND BA IN THE SAME MODEL DUE TO HIGH CORRELATION
#### TPA AND DQRATIO HIGH CORRELATION
#### CCF AND BAL AND BA HIGH CORR
#### BA and BAL HIGH CORR

#"tpa.pl.all" "qmd.pl.all" "ba.pl"      "ccf.pl"

### HIGH CORRS UPDATE: TPA-DQ, BA-QMD, CCF-BA
#no dq and tpa - dropped dq for this option
op1 <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(bal.pl.ratio) + s(tpa.pl.all) + s(qmd.pl.all) + s(ccf.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #using tpa, no dqratio, noBA

op2 <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(bal.pl.ratio) + s(dq.pl.all) + s(qmd.pl.all) + s(ccf.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #no ba, keep dq, no tpa

op3 <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(bal.pl.ratio) + s(dq.pl.all) + s(ba.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #noccf, noqmd, notpa

op4 <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(bal.pl.ratio) + s(tpa.pl.all) + s(ba.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #noccf, noqmd, nodq



opslist <- list('op1'=op1, 'op2'=op2, 'op3'=op3, 'op4'=op4)

lapply(opslist, rmse.conc)

#### OP2 wins
### follwed by: op1, op4, op3

## if i use 0.8 as the concurvity threshold, then these are all fine (if I'm loooking at the estimate)

## if i drop to 0.5, then none of these options work


```


```{r evaluate tree-level with site, include = F}
## compare partial responses
gam.s1a <- gam(bai~s(DIAMETER), family = 'Gamma'(link = log), data = bai.size[bai.size$unique_tree_id != 15431,], method = 'ML') 
# for(i in compdlist.full){
#   par(mfrow = c(1,2))
#   plot.gam(asp.sincos3, rug = F, select = 1, ylim = c(-1.6, 2))
#   plot.gam(i, rug = F, select = 1, ylim = c(-1.6, 2), main = print(names(i)[1]))
# }


# for(i in compdlist.ind){
#   par(mfrow = c(1,2))
#   plot.gam(asp.sincos3, rug = F, select = 1, ylim = c(-1.6, 2))
#   plot.gam(i, rug = F, select = 1, ylim = c(-1.6, 2))
# }


for(i in nosite.compdlist.full){
  par(mfrow = c(1,2))
  plot.gam(gam.s1a, rug = F, select = 1, ylim = c(-1.6, 2))
  plot.gam(i, rug = F, select = 1, ylim = c(-1.6, 2))
}


for(i in nosite.compdlist.ind){
  par(mfrow = c(1,2))
  plot.gam(gam.s1a, rug = F, select = 1, ylim = c(-1.6, 2))
  plot.gam(i, rug = F, select = 1, ylim = c(-1.6, 2))
}



#plot.gam(compd.dq, rug = F, select = 1, ylim = c(-1.6, 2))

#plot.gam(asp.sincos3, rug = F, select = 2, ylim = c(-1.6, 2))
#plot.gam(compd1, rug = F, select = 2, ylim = c(-1.6, 2))

#plot.gam(asp.sincos3, rug = F, select = 3, ylim = c(-1.6, 2))
#plot.gam(compd1, rug = F, select = 3, ylim = c(-1.6, 2))

#pred1 <- predict(asp.sincos3, type = 'link', se.fit = T)
#pred2 <- predict(compd1, type = 'link', se.fit = T)
#ilink <- family(asp.sincos3)$linkinv
#ilink2 <- family(compd1)$linkinv
#prdfits1 <- tibble('fit1'=pred1$fit, 'sefit1' = pred1$se.fit) 
#prdfits2 <- tibble('fit2' = pred2$fit, 'sefit2'=pred2$se.fit)
#prdfits1 <- prdfits1 %>% 
#  mutate(lwr_ci1 = ilink(fit1-(2*sefit1)), 
#         upr_ci1 = ilink(fit1+(2*sefit1)), 
#         fit1 = ilink(fit1),
#         var.m1=asp.sincos3$model$DIAMETER)
#prdfits2 <- prdfits2 %>% 
#  mutate(lwr_ci2 = ilink(fit2-(2*sefit2)), 
#         upr_ci2 = ilink(fit2+(2*sefit2)), 
#         fit2 = ilink(fit2),
#         var.m2=compd1$model$DIAMETER)
#ggplot(prdfits1, aes(x = var.m1, y = fit1)) + geom_point() geom_line() + geom_line(data = prdfits2, aes(x = var.m2, y = fit1))



```

```{r evaluate without site}
#starting to evaluate concurvity estimate, instead of "worst", ????and changing the threshold to 0.5..???
(full.lst <- lapply(nosite.compdlist.full, rmse.conc))
(ind.lst <- lapply(nosite.compdlist.ind, rmse.conc))


## BEST INDIVIDUAL - CROWN RATIO
# change in rmse - 
rmse.conc(gam.s1a)$rmse.df - ind.lst$cr$rmse.df
rmse.conc(gam.s1a)$rmse.df - ind.lst$bal$rmse.df
rmse.conc(gam.s1a)$rmse.df - ind.lst$dq$rmse.df


full.lst$`cr-bal`


### by my fitting algorithm, combo should be cr and bal

### 

#adds a third (logical) object to list which tests if there is any concurvity estimate >= 0.8
#for(i in 1:length(full.lst)){
#  full.lst[[i]][[3]] <- ifelse(any(full.lst[i][[1]][[2]][3,]>=0.8), 'concurve', 'no-concurve')
#}



#in this case, then, the full compd model works best... but let's see what happens when I add plot-vars
```



First iteration - all variables. 
BAL and crown ratio are effectively linear terms - or at least close to it.

Concurvity is an ISSUE: 
- aspect and diameter are highly concurve, slope and aspect are highly concurve
- others to note: diameter-dq, diameter-bal, aspect-cr, aspect-dq, bal-dq

Where do i go from here? 

Even the individual variables versions are having trouble with concurvity

Options
1. drop slope from the model, try again
2. try trasp in place of sin,cos-asp
3. keep going down the list of other aspect options 



```{r ALT1 plot-level using new model fit process for plot}
#"tpa.pl.all" "qmd.pl.all" "ba.pl"      "ccf.pl"

### STARTING WITH CR + BAL
formula(nosite.compd2)

### HIGH CORRS UPDATE: TPA-DQ, BA-QMD, CCF-BA

compd.pl1 <- update(nosite.compd2, . ~ . + s(tpa.pl.all))
compd.pl2 <- update(nosite.compd2, . ~ . + s(qmd.pl.all))
compd.pl3 <- update(nosite.compd2, . ~ . + s(ba.pl))
compd.pl4 <- update(nosite.compd2, . ~ . + s(ccf.pl))

compd.pl.lst <- list('tpa' = compd.pl1, 'qmd' = compd.pl2, 'ba' = compd.pl3, 'ccf' = compd.pl4)
compd.pl.lst.rc <- lapply(compd.pl.lst, rmse.conc)
compd.pl.lst.rc[[1]][[1]]
rmse.conc(nosite.compd2)$rmse.df
diff <- .5*(rmse.conc(nosite.compd2)$rmse.df - rmse.conc(compd.pl4)$rmse.df)
vec <- vector()

for(i in 1:length(compd.pl.lst)){
  vec[i] <- (compd.pl.lst.rc[[i]][[1]])
}
vec
(rmse.conc(nosite.compd3)$rmse.df-vec) >= diff

## the above suggests that tpa shouldn't be considered (because tpa alone does not change rmse by at least half of the difference that qmd makes)

#ranks: 1. ccf, ba, qmd, tpa
formula(compd.pl4a)
#add ccf
compd.pl4a <- update(compd.pl4, . ~ . + s(ccf.pl))
#add qmd to ccf
compd.pl4b <- update(compd.pl4, . ~ . + s(ccf.pl) + s(qmd.pl.all))
#include tpa for kicks
compd.pl4c <- update(compd.pl4, . ~ . + s(ccf.pl) + s(qmd.pl.all) + s(tpa.pl.all))

pl.1.lst <- list(compd.pl4a, compd.pl4b, compd.pl4c)

## let's see if tpa makes a noteworthy difference in rmse..
rmse.conc(compd.pl4)
lapply(pl.1.lst, formula)
lapply(pl.1.lst, rmse.conc)

###### it seems like CCF alone does the best job here. compd.pl4a

```

```{r ALT1a alternate - consider ba before ccf}
# ALTERNATE - let's look at the other options too - starting with ba instead of ccf

#add ba
compd.pl4.a1 <- update(compd.pl4, . ~ . + s(ba.pl))
## again, add tpa, although I'm not stoked on it
compd.pl4.a2 <- update(compd.pl4, . ~ . + s(ba.pl) + s(tpa.pl.all))

#add qmd
compd.pl4.b1 <- update(compd.pl4, . ~ . + s(qmd.pl.all))
#include tpa for kicks
compd.pl4.b2 <- update(compd.pl4, . ~ . + s(qmd.pl.all) + s(tpa.pl.all))


pl.2.lst <- list(compd.pl4.a1, compd.pl4.a2, compd.pl4.b1, compd.pl4.b2)
rmse.conc(compd.pl4)
lapply(pl.2.lst, rmse.conc)

### CCF wins over BA

```


```{r try writing gam fit algorithm, include = F}

#set up groups
compd.tree <- bai.dcomp %>% select(cr, bal.pl.ratio, dq.pl.all)
compd.plot <- bai.dcomp %>% select(tpa.pl.all, qmd.pl.all, ba.pl, ccf.pl)
compd.all <- bai.dcomp %>% select(cr, bal.pl.ratio, qmd.pl.all, dq.pl.all, tpa.pl.all, ba.pl, ccf.pl)

#name lists for logical test for subgroups
tree.metrics <- names(compd.tree)
plot.metrics <- names(compd.plot)

#model to build off of
base <- gam(bai~s(DIAMETER), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')

#create empty list to store model objects
modellist <- list()

#determine best single variable

fits <- lapply(bai.dcomp[bai.dcomp$unique_tree_id != 15431, c("bal.pl.ratio", 'dq.pl.all')], function(x){
  gam(bai~s(DIAMETER) + s(x)
      , family = 'Gamma'(link = log), 
      data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML')
  })

#rmse and concurvity
rmseconc <- sapply(fits, rmse.conc, simplify = F)
str(rmse.conc)
sapply(rmseconc, function(x) (x[2]))

unlist(sapply(rmseconc, function(x) x[1], USE.NAMES = T))


t(as.data.frame(concurvity(op1)))
```


```{r, include = F}
concurvity(op2, full = F)
```

```{r testing adding site vars, include = F}
#in the case we select op2

op2.asp <- update(op2, . ~ . + s(asp_sin, asp_cos) + s(slope_pct))
op2.htld <- update(op2, . ~ . + s(heatload))
formula(op2.asp)

concurvity(op2)
concurvity(op2.asp)
concurvity(op2.htld)

rmse.conc(op2.asp)
rmse.conc(op2.htld)


```


```{r plot level variable selection - site first, include = F}
### Add plot-level vars
#### SHOULD NOT USE CCF AND BA IN THE SAME MODEL DUE TO HIGH CORRELATION
#### TPA AND DQRATIO HIGH CORRELATION
#### CCF AND BAL AND BA HIGH CORR
#### BA and BAL HIGH CORR

op1 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(elev_m) + s(slope_pct) + s(cr, k = 9) + s(bal.pl) + s(tpa.pl.all), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #using tpa, no dqratio, no ba, no ccf

op2 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(elev_m) + s(slope_pct) + s(cr, k = 9) + s(tpa.pl.all) + s(ccf.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #use tpa and ccf, no DQ, no BAL, no BA

op3 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(elev_m) + s(slope_pct) + s(cr, k = 9) + s(dq.pl.all) + s(ba.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #using BA, no BAL, no ccf

op4 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(elev_m) + s(slope_pct) + s(cr, k = 9) + s(dq.pl.all) + s(ccf.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #ccf, no bal, no ba

op2a <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(elev_m) + s(slope_pct) + s(cr, k = 9) + s(bal.pl) + s(dq.pl.all) + s(tpa.pl.all) + s(ccf.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #use tpa and ccf, ignore cross-correlations?

op3a <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(elev_m) + s(slope_pct) + s(cr, k = 9) + s(bal.pl) + s(dq.pl.all) + s(ba.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #use BA, no ccf, but ignore cross-corrs 

op5a <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(elev_m) + s(slope_pct) + s(cr, k = 9) + s(bal.pl) + s(dq.pl.all) + s(tpa.pl.all) + s(ba.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #use ba and tpa together, ignore cross-corrs?

opslist <- list('tpa-exothers' = op1, 'tpa,ccf-exdq,bal,ba' = op2, 'ba-exothers' = op3, 'ccf-exothers' = op4, 'tpaccf-ignorecorrs' = op2a, 'ba-exccf-ignorecorrs' = op3a, 'batpa-ignorecorrs' = op5a)

lapply(opslist, rmse.conc)

```

```{r tuning the full model - site first, include = F}
op3 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(elev_m) + s(slope_pct) + s(cr, k = 9) + s(dq.pl.all) + s(ba.pl, k = 20) + ti(), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #using BA, no BAL, no ccf
summary(op3)
#print(plot(getViz(op3, allTerms = T)), pages = 2)
#draw(op3, residuals = T, scales = 'free')
#pt <- visreg(fit = op3, type = 'contrast', plot = F, data = bai.dcomp)
plot.gam(op3, pages = 2, scale = 0, scheme = 1, trans = exp, all.terms = T)
par(mfrow=c(2,2))
gam.check(op3)
options(digits = 4)
concurvity(op3)
concurvity(op3, full = F)

#higher concurvity values
## DIAMETER - s(asp_cos, asp_sin), s(dq.pl.all), s(ba.pl)
## ASPECT - s(DIAMETER), s(elev_m), s(slope_pct), s(ba.pl)
## ELEVATION - ASPECT, slope (kinda)
## SLOPE - DIAMETER ASPECT ELEVATION
## DQ - DIAMETER
## BA - DIAMETER, ASPECT

ggplot(bai.dcomp, aes(x = ba.pl, y = asp.trasp)) + geom_point()

```

```{r best single variable - site first, include = F}
#select(cr, bal.pl, dq.pl.all, tpa.pl.all, ba.pl, ccf.pl, HabType)


best.1 <-  gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(cr, k = 9), family = 'Gamma'(link = log), bai.dcomp[bai.dcomp$unique_tree_id != 15431,])

best.2 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(bal.pl), family = 'Gamma'(link = log), bai.dcomp[bai.dcomp$unique_tree_id != 15431,])

best.3 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(dq.pl.all), family = 'Gamma'(link = log), bai.dcomp[bai.dcomp$unique_tree_id != 15431,])

best.4 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(tpa.pl.all), family = 'Gamma'(link = log), bai.dcomp[bai.dcomp$unique_tree_id != 15431,])

best.5 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(ba.pl), family = 'Gamma'(link = log), bai.dcomp[bai.dcomp$unique_tree_id != 15431,])

best.6 <- gam(bai~s(DIAMETER) + s(asp_cos, asp_sin) + s(ccf.pl), family = 'Gamma'(link = log), bai.dcomp[bai.dcomp$unique_tree_id != 15431,])

best.list <- list('best1' = best.1, 'best2' = best.2, 'best3' = best.3, 'best4' = best.4, 'best5' = best.5, 'best6' = best.6)

lapply(best.list, rmse.conc)
lapply(best.list, concurvity)

## no surprise, BA is the best, but that doesn't come without issues of concurvity
```

```{r take a look beyond rmse}

plot.gam(op2, pages = 2)
plot.gam(compd.pl4, pages = 2)

summary(op2)
summary(compd.pl4)

par(mfrow = c(2,2))
gam.check(op2)
gam.check(compd.pl4)

anova.gam(op2, compd.pl4, test = 'Chisq')
```




```{r all individuals}

best.1 <- nosite.compd.cr

best.2 <- nosite.compd.bal

best.3 <- nosite.compd.dq

best.4 <- gam(bai~s(DIAMETER) + s(tpa.pl.all), family = 'Gamma'(link = log), bai.dcomp[bai.dcomp$unique_tree_id != 15431,])

best.5 <- gam(bai~s(DIAMETER) + s(ba.pl), family = 'Gamma'(link = log), bai.dcomp[bai.dcomp$unique_tree_id != 15431,])

best.6 <- gam(bai~s(DIAMETER) + s(ccf.pl), family = 'Gamma'(link = log), bai.dcomp[bai.dcomp$unique_tree_id != 15431,])

best.7 <- gam(bai~s(DIAMETER) + s(qmd.pl.all), family = 'Gamma'(link = log), bai.dcomp[bai.dcomp$unique_tree_id != 15431,])

best.4a <- update(best.4, . ~ . + s(cr, k = 9))

best.5a <- update(best.5, . ~ . + s(cr, k = 9))

best.6a <- update(best.6, . ~ . + s(cr, k = 9))

best.7a <- update(best.7, . ~ . + s(cr, k = 9))

best.list.tree <- list('cr' = best.1, 'bal' = best.2, 'dq' = best.3) 

best.list.plot <- list('tpa' = best.4, 'ba' = best.5, 'ccf' = best.6, 'qmd' = best.7)

best.list.plot.withtree <- list('cr.tpa' = best.4a, 'cr.ba' = best.5a, 'cr.ccf' = best.6a, 'cr.qmd' = best.7a)

lapply(best.list.tree, rmse.conc)
lapply(best.list.plot, rmse.conc)
lapply(best.list.plot.withtree, rmse.conc)
```




```{r FVS model}

fvs.full <- glm(log.bai~elev_m + I(elev_m^2) + sl_asp_sin + sl_asp_cos + slope_pct + I(slope_pct^2) + I(ccf.cl/100) + log.diam + I(bal.cl/100) + cr + I(cr^2) + I(DIAMETER^2) + I(bal.cl/(100*log(DIAMETER+1))) + factor(habclass), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,])
summary(fvs.full)
my.rmse.2(fvs.full)

```

```{r RMSE tables}
#best of original selection - no site
op2

#best from new selection methods - no site
compd.pl4a



```







OMISSIONS

# op2 <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(tpa.pl.all) + s(ccf.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #use tpa and ccf, no DQ, no BAL, no BA
# 
# op3 <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(dq.pl.all) + s(ba.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #using BA, no BAL, no ccf
# 
# op4 <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(dq.pl.all) + s(ccf.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #ccf, no bal, no ba

# op2a <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(bal.pl) + s(dq.pl.all) + s(tpa.pl.all) + s(ccf.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #use tpa and ccf, ignore cross-correlations?
# 
# op3a <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(bal.pl) + s(dq.pl.all) + s(ba.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #use BA, no ccf, but ignore cross-corrs 
# 
# op5a <- gam(bai~s(DIAMETER) + s(cr, k = 9) + s(bal.pl) + s(dq.pl.all) + s(tpa.pl.all) + s(ba.pl), family = 'Gamma'(link = log), data = bai.dcomp[bai.dcomp$unique_tree_id != 15431,], method = 'ML') #use ba and tpa together, ignore cross-corrs?

# opslist <- list('tpa-exothers' = op1, 'tpa,ccf-exdq,bal,ba' = op2, 'ba-exothers' = op3, 'ccf-exothers' = op4, 'tpaccf-ignorecorrs' = op2a, 'ba-exccf-ignorecorrs' = op3a, 'batpa-ignorecorrs' = op5a)
