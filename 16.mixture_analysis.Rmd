---
title: "different_mixtures"
author: "Christian Mercado"
date: '2022-07-20'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#readin
library(gratia)
library(tidyverse)
library(mgcv)
library(gridExtra)
source('12.gam_fns.R')

hab_loc_codes <- read_csv('data/habtypes.csv')
hab_loc_codes <- hab_loc_codes %>% select(SETTING_ID, habclass, locationcode)
bai.train <- readRDS('data/bai.train.7_14_22.rds')
bai.train <- left_join(bai.train, hab_loc_codes, by = "SETTING_ID")

bai.spmx <- bai.train %>% 
  select(SETTING_ID, stand, MEASUREMENT_NO, myear, PLOT, cluster, unique_tree_id, 
         bai, DIAMETER, treeba, log.diam, log.bai, grwth.yr, mean_si, aspect_deg, 
         heatload, slope_deg, elev_m, NF, CROWN_RATIO, tpa.pl.all, tpa.pl.cutoff,
         ba.pl, bal.pl, ccf.pl, ccf.nospp, qmd.pl.all, qmd.pl.cutoff, dq.pl.all, 
         dq.pl.cutoff, tpa.cl.all, tpa.pl.cutoff,
         ba.cl, ccf.cl, bal.cl, dq.cl.all, dq.cl.cutoff, HabType, habclass,
         locationcode, percent_LAOC, shade.tol.pl, dom.spp.pl.ba, percent_PSME, 
         percent_PIEN, percent_ABLA, percent_ABGR, percent_PICO, percent_PIPO, percent_other) %>% 
  mutate(slope_pct = tan(slope_deg*(pi/180))*100, 
         asp_sin = sin(aspect_deg*(pi/180)),
         asp_cos = cos(aspect_deg*(pi/180))) %>%
  mutate(sl_asp_sin = asp_sin*slope_pct, 
         sl_asp_cos = asp_cos*slope_pct, 
         asp.trasp = trasp(aspect_deg), 
         HabType = as.factor(HabType),
         cr = CROWN_RATIO/100,
         bal.pl.ratio = bal.pl/ba.pl,
         unique_tree_id = factor(unique_tree_id)) %>% 
  filter(bai != 0)


bai.spmx.ids <- bai.spmx %>% 
  group_by(stand) %>% 
  mutate(unique.stand = cur_group_id()) %>%
  ungroup() %>% 
  mutate(unique.cluster = (1000*unique.stand)+cluster, 
         unique.plot = (1000*unique.stand)+PLOT) %>% 
  mutate(unique.cluster.meas = as.factor(unique.cluster + MEASUREMENT_NO), 
         unique.plot.meas = as.factor(unique.plot + MEASUREMENT_NO),
         unique.cluster.f = as.factor(unique.cluster), 
         unique.plot.f = as.factor(unique.plot), 
         unique.tree.f = as.factor(unique_tree_id)) %>% 
  filter(unique_tree_id != 15431)
rm(bai.spmx)

#null model to compare to for results
#re.tree.1alt <- readRDS('data/model_objects.1/re.tree.1alt.rds')
#larch fraction - alternative with random 
# spmx.gam.alt.lf <- readRDS('data/model_objects.1/spmx.gam.alt.lf_7.11.rds')
#shade tol - alternative with random
# spmx.gam.alt.st <- readRDS('data/model_objects.1/spmx.gam.alt.st.rds')
```

```{r}
# metric cateogrizing larch with each other species
# larch.mixtures <- function(data, species, maximum, combined_min){
#   a <- data %>% filter(percent_LAOC < maximum & '{species}' < maximum & (percent_LAOC+'{species}') > combined_min)
#   return(a)
# }
# bai.spmx.ids %>% filter(percent_LAOC>0.4 & percent_PSME>0.4 & (percent_LAOC+percent_PSME)>0.6)

# larch.mixtures(bai.spmx.ids, percent_PSME, maximum = 0.8, combined_min =.4)

spp.fun <- function(data.set, spp_min, spp_maximum, combined_min){
  a <- data.set %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_PSME<spp_maximum & percent_PSME>spp_min, 
                               (percent_LAOC+percent_PSME)>combined_min) %>% 
    mutate(other.pct = percent_PSME)
  b <- data.set %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_ABLA<spp_maximum & percent_ABLA>spp_min, 
                               (percent_LAOC+percent_ABLA)>combined_min) %>% 
    mutate(other.pct = percent_ABLA)
  c <- data.set %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_ABGR<spp_maximum & percent_ABGR>spp_min, 
                               (percent_LAOC+percent_ABGR)>combined_min) %>% 
    mutate(other.pct = percent_ABGR)
  d <- data.set %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_PIEN<spp_maximum & percent_PIEN>spp_min, 
                               (percent_LAOC+percent_PIEN)>combined_min) %>% 
    mutate(other.pct = percent_PIEN)
  e <- data.set %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_PICO<spp_maximum & percent_PICO>spp_min, 
                               (percent_LAOC+percent_PICO)>combined_min) %>% 
    mutate(other.pct = percent_PICO)
  f <- data.set %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_PIPO<spp_maximum & percent_PIPO>spp_min, 
                               (percent_LAOC+percent_PIPO)>combined_min) %>% 
    mutate(other.pct = percent_PIPO)
  g <- data.set %>% filter(percent_LAOC>combined_min) %>% 
    mutate(other.pct = percent_LAOC)
   return(list('psme'=a, 'abla'=b, 'abgr'=c, 'pien'=d, 'pico'=e, 'pipo'=f, 'laoc' = g))
  }
mixtures <- spp.fun(bai.spmx.ids, 0.2, .65, 0.7)
individual.obs <- lapply(mixtures, function(x)
  length(unique(x$unique_tree_id)))
mix.w.names <- map(names(mixtures), ~mixtures[[.x]] %>% mutate(mixtype = .x))

mixtures.all <- bind_rows(mix.w.names)

mix.w.names <- map(names(mixtures), ~mixtures[[.x]] %>% mutate(mixtype = .x)) # add names to different mixes in the data

mixtures.all <- bind_rows(mix.w.names) #list to tibble

o.mixtures.all <- mixtures.all %>% 
  select(SETTING_ID, stand, PLOT, bai, DIAMETER, cr, 
         bal.pl.ratio, ba.pl, asp_sin, asp_cos, mixtype, 
         unique_tree_id, NF, cluster) %>% 
  filter(mixtype %in% c('psme', 'pien', 'pico', 'laoc')) %>% 
  mutate(mixtype = as.factor(mixtype)) %>% 
  mutate(omixtype = ordered(mixtype, levels = c('laoc', 'pico', 'psme', 'pien')))
# (dbh.plots <- lapply(mixtures, function(m)
#   p <- ggplot(m, aes(x = DIAMETER)) + geom_histogram()))
# (dens.plots <- lapply(mixtures, function(m)
#   p <- ggplot(m, aes(x = ba.pl)) + geom_histogram()))
# (bai.plots <- lapply(mixtures, function(m)
#   p <- ggplot(m, aes(x = bai)) + geom_histogram()))

# rm(bai.plots)

#summary plots of average tree bai and diameter

#figure#####
# full.mix <- bind_rows(mixtures, .id = 'id')
# 
# bai.diam <- full.mix %>% 
#   group_by(NF, stand, PLOT, id, unique_tree_id) %>% 
#   summarise(meanbai = mean(bai), meandbh = mean(DIAMETER))
# 
# ggplot(bai.diam, aes(x = meandbh, y = meanbai)) + geom_point() + geom_smooth(se = F) + facet_wrap(~id)
```

```{r read in models}
#fit gam with difference smooths

mix.diff.gam.m1 <- readRDS('data/model_objects.1/mix.diff.gam.m1.rds')
mix.diff.gam <- readRDS('data/model_objects.1/mix.diff.gam.rds')


#summary and model check
job::job(import = c(mix.diff.gam), 
         {library(mgcv) 
           sum.mixdiff = summary.gam(mix.diff.gam)
           check.mdg = gam.check(mix.diff.gam)
           conc.mixdiff = concurvity(mix.diff.gam)})

job::job(import = c(mix.diff.gam.m1),
         {library(mgcv)
           sum.mixdiff.m1 = summary(mix.diff.gam.m1)
           check.mdg.m1 = gam.check(mix.diff.gam.m1)
           conc.mixd.m1})

#resids for groups
modfit <- mix.diff.gam.m1$fitted.values
modres <- mix.diff.gam.m1$residuals
xyplot(modres~modfit|o.mixtures.all$omixtype)

#
sum.mixdiff
sum.mixdiff.m1

concurvity(mix.diff.gam, full = F)

diam.diff.gam <- bam(bai~ mixtype + s(DIAMETER) + s(DIAMETER, by = omixtype) + 
                          s(cr, k = 9) +
                          s(bal.pl.ratio) +
                          s(ba.pl) +
                          s(asp_sin, asp_cos, k = 20),
                         method = 'fREML',
                         family = 'Gamma'(link = log), data = o.mixtures.all)
concurvity(diam.diff.gam, full = F)

sum.mixdiff.m1$

anova(anv.mdif,sum.mixdiff, test = 'Chisq')
AIC(mix.diff.gam)
AIC(mix.diff.gam.m1)
```

```{r fitting the diff models}
#fitting models#####
# The purpose of m=1 is to reduce collinearity between the smooth differences and the reference smooth
# mix.diff.gam.m1
#       bam(bai~ mixtype + s(DIAMETER) + s(DIAMETER, by = omixtype, m=1) + 
#                           s(cr, k = 9) + s(cr, by = omixtype, k = 9, m=1) + 
#                           s(bal.pl.ratio) + s(bal.pl.ratio, by = omixtype, m=1) + 
#                           s(ba.pl) + s(ba.pl, by = omixtype) +
#                           s(asp_sin, asp_cos, k = 20) + s(asp_sin, asp_cos, by = omixtype, k = 20,m=1) +
#                           s(unique_tree_id, bs = 're'),
#                         family = 'Gamma'(link = log), data = o.mixtures.all, method = 'fREML'))
# try(saveRDS(mix.diff.gam.m1, 'C:/Users/cm165878/Box/research_/mix.diff.gam.m1.rds'))
# try(saveRDS(mix.diff.gam.m1, 'data/model_objects.1/mix.diff.gam.m1.rds'))

# this one is without the m=1
## m=1 tells it to penalize the 1st derivative instead of the usual 2nd.
## contrains the null space
# mix.diff.gam <- 
# bam(bai~ mixtype + s(DIAMETER) + s(DIAMETER, by = omixtype) + 
#                           s(cr, k = 9) + s(cr, by = omixtype, k = 9) + 
#                           s(bal.pl.ratio) + s(bal.pl.ratio, by = omixtype) + 
#                           s(ba.pl) + s(ba.pl, by = omixtype) +
#                           s(asp_sin, asp_cos, k = 20) + s(asp_sin, asp_cos, by = omixtype, k = 20) +
#                           s(unique_tree_id, bs = 're'),
#                         family = 'Gamma'(link = log), data = o.mixtures.all, method = 'fREML'))


# These were mostly exploratory for each variable#####

# this one only evaluates diameter smooth differences
# try(diam.diff.gam <- bam(bai~ mixtype + s(DIAMETER) + s(DIAMETER, by = omixtype) + 
#                           s(cr, k = 9) + 
#                           s(bal.pl.ratio) + 
#                           s(ba.pl) +
#                           s(asp_sin, asp_cos, k = 20) +
#                           s(unique_tree_id, bs = 're'), method = 'fREML',
#                         family = 'Gamma'(link = log), data = o.mixtures.all))
#this one only looks at diameter, but without REs
# try(diam.nore<- bam(bai~ mixtype + s(DIAMETER) + s(DIAMETER, by = omixtype) + 
#                           s(cr, k = 9) + 
#                           s(bal.pl.ratio) + 
#                           s(ba.pl) +
#                           s(asp_sin, asp_cos, k = 20) , method = 'fREML',
#                         family = 'Gamma'(link = log), data = o.mixtures.all))
# plot(diam.nore, ylim = c(-2, 2), seWithMean = T)
# summary(diam.nore)

# this one does CR
# cr.nore <- bam(bai~ mixtype + s(DIAMETER) + 
#                           s(cr, k = 9) + s(cr, k = 9, by = omixtype) + 
#                           s(bal.pl.ratio) + 
#                           s(ba.pl) +
#                           s(asp_sin, asp_cos, k = 20) , method = 'fREML',
#                         family = 'Gamma'(link = log), data = o.mixtures.all)
# plot(cr.nore, ylim = c(-2, 2))
# summary(cr.nore)
# 
#this one does bal
# bal.nore <- bam(bai~ mixtype + s(DIAMETER) + 
#                           s(cr, k = 9) + 
#                           s(bal.pl.ratio) + s(bal.pl.ratio, by = omixtype) +
#                           s(ba.pl) +
#                           s(asp_sin, asp_cos, k = 20) , method = 'fREML',
#                         family = 'Gamma'(link = log), data = o.mixtures.all)
# plot(bal.nore, ylim = c(-2, 2))
# summary(bal.nore)
# 
# this one does ba
# ba.nore <- bam(bai~ mixtype + s(DIAMETER) + 
#                           s(cr, k = 9) + 
#                           s(bal.pl.ratio) + 
#                           s(ba.pl) + s(ba.pl, by = omixtype) +
#                           s(asp_sin, asp_cos, k = 20) , method = 'fREML',
#                         family = 'Gamma'(link = log), data = o.mixtures.all)
# plot(ba.nore, ylim = c(-2, 2))
# summary(ba.nore)
# 
# this one does aspect
# asp.nore <- bam(bai~ mixtype + s(DIAMETER) + 
#                           s(cr, k = 9) + 
#                           s(bal.pl.ratio) + 
#                           s(ba.pl) + s(ba.pl, by = omixtype) +
#                           s(asp_sin, asp_cos, k = 20) + s(asp_sin, asp_cos, k = 20, by = omixtype), 
#                 method = 'fREML',
#                 family = 'Gamma'(link = log), data = o.mixtures.all)
# plot(asp.nore, scheme = 1)
# summary(asp.nore)
# 
# 
# plot(mix.diff.gam, shade = T, scale = 0, seWithMean = T)
# 
# saveRDS(mix.diff.gam, 'data/model_objects.1/mix.diff.gam729_lab.rds')

```


```{r fit gams}
#fit gams for subsets of data
laoc_psme <- mixtures$psme
# hist(laoc_psme$bai)
# length(unique(laoc_psme$asp_sin))
# ggplot(laoc_psme, aes(x = percent_LAOC, y = percent_PSME)) + geom_point()
psme.gam <- readRDS('data/model_objects.1/psme.gam_728.rds')
  # gam(bai~ s(DIAMETER) + s(cr, k = 8) + s(bal.pl.ratio) + s(ba.pl)+
  #                     s(asp_sin, asp_cos, k = 20) + s(unique_tree_id, bs = 're'),
  #                   family = 'Gamma'(link = log),
  #                   data = laoc_psme, method = 'ML')
# med.psme <- median(laoc_psme)
# summary(laoc_psme$DIAMETER)


laoc_pico <- mixtures$pico
# length(unique(laoc_pico$cr))
# hist(laoc_pico$bai)
# plot(laoc_pico$DIAMETER, laoc_pico$bai)
# filter(laoc_pico, bai>3)
# ggplot(laoc_pico, aes(x = percent_LAOC, y = percent_PICO)) + geom_point()
pico.gam <- readRDS('data/model_objects.1/pico.gam728.rds')
  # gam(bai~ s(DIAMETER) + s(cr, k = 7) + s(bal.pl.ratio) + s(ba.pl)+
  #                     s(asp_sin, asp_cos, k = 13) + s(unique_tree_id, bs = 're'),
  #                   family = 'Gamma'(link = log),
  #                   data = laoc_pico, method = 'ML')
# saveRDS(pico.gam, 'data/model_objects.1/pico.gam728.rds')
# a <- gamm4::gamm4(bai~ s(DIAMETER) + s(cr, k = 7) + s(bal.pl.ratio) + s(ba.pl)+
#                       s(asp_sin, asp_cos, k = 13),
#                     random=~(1|unique_tree_id),
#                     family = 'Gamma'(link = log),
#                     data = laoc_pico, method = 'ML')
# laoc_pico$unique_tree_id
# summary(pico.gam$lme)

laoc_pien <- mixtures$pien
# ggplot(laoc_pien, aes(x = percent_LAOC, y = percent_PIEN)) + geom_point()
# length(unique(laoc_pien$asp_sin))
# length(unique(laoc_pien$cr))
pien.gam <- readRDS('data/model_objects.1/pien.gam728.rds')
  # gam(bai~ s(DIAMETER) + s(cr, k = 8) + s(bal.pl.ratio) + s(ba.pl)+
  #                     s(asp_sin, asp_cos, k = 8) + s(unique_tree_id, bs = 're'),
  #                   family = 'Gamma'(link = log),
  #                   data = laoc_pien, method = 'ML')
# saveRDS(pien.gam, 'data/model_objects.1/pien.gam728.rds')

laoc_laoc <- mixtures$laoc
# length(unique(laoc_laoc$asp_sin))
laoc.gam <- readRDS('data/model_objects.1/laoc.gam728.rds')
  # gam(bai~ s(DIAMETER) + s(cr, k = 9) + s(bal.pl.ratio) + s(ba.pl)+
  #                     s(asp_sin, asp_cos, k = 20) + s(unique_tree_id, bs = 're'),
  #                   family = 'Gamma'(link = log),
  #                   data = laoc_laoc, method = 'ML')
# saveRDS(laoc.gam, 'data/model_objects.1/laoc.gam728.rds')

mod.list <- list('psme'=psme.gam, 'pico'=pico.gam, 'pien'=pien.gam, 'laoc'=laoc.gam)
lapply(mod.list, gam.check)
# plot(pico.gam)
# filter(bai.spmx.ids, unique_tree_id == 2505)
# bbb <- readRDS('data/bai.shade.rds')
# bbb %>% filter(unique_tree_id == 2505)
# bbb %>% filter(!(unique_tree_id == 2505 & MEASUREMENT_NO == 4))
# rm(data)
# plot.gam(mod.list[[1]])
## change bai to 4.611038134
# summary(laoc.gam)
# summary(pico.gam)
# summary(psme.gam)
# summary(pien.gam)
laoc.gam$coefficients[[1]]
for(i in 1:5){
  par(mfrow = c(2,2))
  plot(laoc.gam, residuals = T, trans = exp, select = i, ylim = c(0,4), shift = laoc.gam$coefficients[[1]])
  plot(pico.gam, residuals = T, trans = exp, select = i, ylim = c(0,4), shift = pico.gam$coefficients[[1]])
  plot(psme.gam, residuals = T, trans = exp, select = i, ylim = c(0,4), shift = psme.gam$coefficients[[1]])
  plot(pien.gam, residuals = T, trans = exp, select = i, ylim = c(0,4), shift = pien.gam$coefficients[[1]])
}
plot(laoc.gam)

bp.psme <- boxplot(laoc_psme$DIAMETER, plot = F)
l.u.psme <- bp.psme$stats[c(2, 4)]
bp.laoc <- boxplot(laoc_laoc$DIAMETER, plot = F)
l.u.laoc <- bp.laoc$stats[c(2,4)]
bp.pico <- boxplot(laoc_pico$DIAMETER, plot = F)
l.u.pico <- bp.pico$stats[c(2, 4)]
bp.pien <- boxplot(laoc_pien$DIAMETER, plot = F)
l.u.pien <- bp.pien$stats[c(2, 4)]


```

```{r summary plot for mixtures}
# lapply(mixtures, function(x) mutate(x, mixwith = print()))
mix.w.names <- map(names(mixtures), ~mixtures[[.x]] %>% mutate(mixtype = .x))

mixtures.all <- bind_rows(mix.w.names)
mixtures.all <- mixtures.all %>%  
  mutate(laoc_to_other = case_when(percent_LAOC/other.pct >= 1 ~ (percent_LAOC/other.pct),
                                   percent_LAOC/other.pct < 1 ~ (other.pct/percent_LAOC))) %>% 
  ungroup() %>% 
  mutate(more.larch = case_when(percent_LAOC/other.pct >= 1 ~ 'yes',
                                percent_LAOC/other.pct < 1 ~ 'no'))
ggplot(subset(mixtures.all, !(mixtype %in% c('abla', 'laoc', 'pipo'))), aes(x = mixtype, y = laoc_to_other)) + geom_jitter(alpha = 0.5, aes(color = more.larch))


  # geom_col(position = position_dodge())
  
mixtures.all %>% group_by(mixtype) %>% summarize(n(), n_distinct(unique_tree_id))

mixtures.all %>% group_by(mixtype, stand, )
```

```{r gratia fitted values version}
## this may not be necessary
#posterior dist. sim
# asp_sin <- rep(sin(315*(pi/180)), 25)
# asp_cos <- rep(cos(315*(pi/180)), 25)
# bal.pl.ratio <- rep(0.6622384, 25)
# ba.pl <- rep(40.83743, 25)
# cr <- rep(0.5, 25)
# unique_tree_id <- rep(sample(laoc.gam$model$unique_tree_id, 1), 25)
# DIAMETER <- (seq(l.u.laoc[1], l.u.laoc[2], length = 25))
# 
# vd <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
# fitted_samples(laoc.gam, newdata = vd)

```



```{r diam and plot fun}
library(ggpubr)


asp_sin <- rep(sin(315*(pi/180)), 25)
asp_cos <- rep(cos(315*(pi/180)), 25)
bal.pl.ratio <- rep(0.6622384, 25)
ba.pl <- rep(40.83743, 25)
cr <- rep(0.5, 25)
# 
# unique_tree_id <- rep(sample(laoc.gam$model$unique_tree_id, 1), 25)
#   #diameter function
# DIAMETER <- (seq(l.u.laoc[1], l.u.laoc[2], length = 25))
# vd <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
# apredict <- predict(laoc.gam, newdata = vd, type = 'link', se.fit = T, exclude = 's(unique_tree_id)')
# ilink(apredict)

#not corrected for smoothing parameter uncertainty#####
diam_fun.a <- function(asp = 315, bal = 0.6622384, ba = 40.83743, cr = 0.5){
  asp_sin <- rep(sin(asp*(pi/180)), 25)
  asp_cos <- rep(cos(asp*(pi/180)), 25)
  bal.pl.ratio <- rep(bal, 25)
  ba.pl <- rep(ba, 25)
  cr <- rep(cr, 25)
  
  unique_tree_id <- rep(sample(laoc.gam$model$unique_tree_id, 1), 25)
  #diameter function
  DIAMETER <- (seq(l.u.laoc[1], l.u.laoc[2], length = 25))
  var.diam.a <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
  bai.diam.a <- predict(laoc.gam, newdata = var.diam.a, type = 'response', se.fit = T, exclude = 's(unique_tree_id)')
  a <- tibble(bai=bai.diam.a[[1]], se = bai.diam.a[[2]], var.diam.a,
              whichmix=rep('larch', 25))
  
  #repeat for psme
  unique_tree_id <- rep(sample(psme.gam$model$unique_tree_id, 1), 25)
  DIAMETER <- (seq(l.u.psme[1], l.u.psme[2], length = 25))
  var.diam.b <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
  bai.diam.b <- predict(psme.gam, newdata = var.diam.b, type = 'response', se.fit = T, exclude = 's(unique_tree_id)')
  b <- tibble(bai=bai.diam.b[[1]], se = bai.diam.b[[2]], var.diam.b, 
              whichmix=rep('doug-fir', 25))
  #repeat for pico
  unique_tree_id <- rep(sample(pico.gam$model$unique_tree_id, 1), 25)
  DIAMETER <- (seq(l.u.pico[1], l.u.pico[2], length = 25))
  var.diam.c <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
  bai.diam.c <- predict(pico.gam, newdata = var.diam.c, type = 'response', se.fit = T, exclude = 's(unique_tree_id)')
  c <- tibble(bai=bai.diam.c[[1]], se = bai.diam.c[[2]], var.diam.c,
              whichmix=rep('lodgepole', 25))
  #repeat for pien
  unique_tree_id <- rep(sample(pien.gam$model$unique_tree_id, 1), 25)
  DIAMETER <- (seq(l.u.pien[1], l.u.pien[2], length = 25))
  var.diam.d <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
  bai.diam.d <- predict(pien.gam, newdata = var.diam.d, type = 'response', se.fit = T, exclude = 's(unique_tree_id)')
  d <- tibble(bai=bai.diam.d[[1]], se = bai.diam.d[[2]], var.diam.d, 
              whichmix=rep('e.spruce', 25))
  
  thing <- rbind(a, b, c, d)
  return(thing)
}



ilink <- function(prediction){
  fitted <- exp(as.vector(prediction$fit))
  se.fitted <- exp(as.vector(prediction$se.fit))
  trans.pred <- tibble(bai = fitted, se = se.fitted)
  return(trans.pred)
}

#taking into account smoothness estimation#####
diam_fun <- function(asp = 315, bal = 0.6622384, ba = 40.83743, cr = 0.5){
  asp_sin <- rep(sin(asp*(pi/180)), 25)
  asp_cos <- rep(cos(asp*(pi/180)), 25)
  bal.pl.ratio <- rep(bal, 25)
  ba.pl <- rep(ba, 25)
  cr <- rep(cr, 25)
  
  unique_tree_id <- rep(sample(laoc.gam$model$unique_tree_id, 1), 25)
  #diameter function
  DIAMETER <- (seq(l.u.laoc[1], l.u.laoc[2], length = 25))
  var.diam.a <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
  bai.diam.a <- predict(laoc.gam, newdata = var.diam.a, type = 'link', se.fit = T, exclude = 's(unique_tree_id)')
  bai.diam.a <- ilink(bai.diam.a)
  a <- tibble(bai=bai.diam.a[[1]], se = bai.diam.a[[2]], var.diam.a,
              whichmix=rep('larch', 25))
  
  #repeat for psme
  unique_tree_id <- rep(sample(psme.gam$model$unique_tree_id, 1), 25)
  DIAMETER <- (seq(l.u.psme[1], l.u.psme[2], length = 25))
  var.diam.b <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
  bai.diam.b <- predict(psme.gam, newdata = var.diam.b, type = 'link', se.fit = T, exclude = 's(unique_tree_id)')
  bai.diam.b <- ilink(bai.diam.b)
  b <- tibble(bai=bai.diam.b[[1]], se = bai.diam.b[[2]], var.diam.b, 
              whichmix=rep('doug-fir', 25))
  #repeat for pico
  unique_tree_id <- rep(sample(pico.gam$model$unique_tree_id, 1), 25)
  DIAMETER <- (seq(l.u.pico[1], l.u.pico[2], length = 25))
  var.diam.c <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
  bai.diam.c <- predict(pico.gam, newdata = var.diam.c, type = 'link', se.fit = T, exclude = 's(unique_tree_id)')
  bai.diam.c <- ilink(bai.diam.c)
  c <- tibble(bai=bai.diam.c[[1]], se = bai.diam.c[[2]], var.diam.c,
              whichmix=rep('lodgepole', 25))
  #repeat for pien
  unique_tree_id <- rep(sample(pien.gam$model$unique_tree_id, 1), 25)
  DIAMETER <- (seq(l.u.pien[1], l.u.pien[2], length = 25))
  var.diam.d <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
  bai.diam.d <- predict(pien.gam, newdata = var.diam.d, type = 'link', se.fit = T, exclude = 's(unique_tree_id)')
  bai.diam.d <- ilink(bai.diam.d)
  d <- tibble(bai=bai.diam.d[[1]], se = bai.diam.d[[2]], var.diam.d, 
              whichmix=rep('e.spruce', 25))
  
  thing <- rbind(a, b, c, d)
  return(thing)
}

test.diamfun <- diam_fun()
test.diamfuna <- diam_fun.a()

summary(test.diamfun$bai)
summary(test.diamfuna$bai)

summary(test.diamfun$se)
summary(test.diamfuna$se)

# ggplot(abcde, aes(x = whichmix, y = se)) + geom_point()
# summary(abcde$bai)

plotting_fun <- function(all.data, ylims = c(0, 4), y.brks = seq(0,4,.25)){
  p1 <- ggplot(all.data) + geom_line(aes(x = DIAMETER, y = bai, color = whichmix)) +
    geom_ribbon(aes(x = DIAMETER, ymin = bai-se, ymax = bai+se, fill = whichmix), alpha = 0.2) +
    scale_y_continuous(breaks = y.brks, limits = ylims)
  return(p1)
}

plotting_fun.pairs <- function(all.data, ylims = c(0, 4), y.brks = seq(0,4,.25)){
  p2 <- ggplot(subset(all.data, whichmix %in% c('larch', 'doug-fir')), 
               aes(x = DIAMETER, y = bai, color = whichmix)) +
    geom_line(aes(x = DIAMETER, y = bai, color = whichmix)) +
    geom_ribbon(aes(x = DIAMETER, ymin = bai-se, ymax = bai+se, fill = whichmix), alpha = 0.2) +
    scale_y_continuous(breaks = y.brks, limits = ylims) +
    scale_color_manual(values = c('larch' = 'black', 'doug-fir' = 'green')) +
    scale_fill_manual(values = c('larch' = 'black', 'doug-fir' = 'green'))
  
  p3 <- ggplot(subset(all.data, whichmix %in% c('larch', 'lodgepole')), 
               aes(x = DIAMETER, y = bai, color = whichmix)) +
    geom_line(aes(x = DIAMETER, y = bai, color = whichmix)) +
    geom_ribbon(aes(x = DIAMETER, ymin = bai-se, ymax = bai+se, fill = whichmix), alpha = 0.2) +
    scale_y_continuous(breaks = y.brks, limits = ylims) +
    scale_color_manual(values = c('larch' = 'black', 'lodgepole' = 'red')) +
    scale_fill_manual(values = c('larch' = 'black', 'lodgepole' = 'red'))
  
  p4 <- ggplot(subset(all.data, whichmix %in% c('larch', 'e.spruce')), 
               aes(x = DIAMETER, y = bai, color = whichmix)) +
    geom_line(aes(x = DIAMETER, y = bai, color = whichmix)) +
    geom_ribbon(aes(x = DIAMETER, ymin = bai-se, ymax = bai+se, fill = whichmix), alpha = 0.2) +
    scale_y_continuous(breaks = y.brks, limits = ylims) +
    scale_color_manual(values = c('larch' = 'black', 'e.spruce' = 'lightblue')) +
    scale_fill_manual(values = c('larch' = 'black', 'e.spruce' = 'lightblue'))
  
  all.things <- ggarrange(p2, p3, p4)
  return(all.things)
}

plotting_fun(test.diamfun)
plotting_fun(test.diamfuna)

plotting_fun.pairs(test.diamfun)
plotting_fun.pairs(test.diamfuna)


unique(test.diamfun$whichmix)
# ggplot(subset(test.diamfun, whichmix %in% c('laoc', 'psme')), 
#                aes(x = DIAMETER, y = bai, color = whichmix)) +
#     geom_point(alpha = 0.2) + 
#     geom_line(aes(x = DIAMETER, y = bai, color = whichmix)) +
#     geom_ribbon(aes(x = DIAMETER, ymin = bai-se, ymax = bai+se, fill = whichmix), alpha = 0.2) +
#     scale_y_continuous(breaks = seq(0,4,.25), limits = c(0, 4))

```

```{r}
#####
# plotting_fun(abcde) + labs(title = 'dog')

# plotting_fun <- function(oblist){
#   p <- ggplot() + geom_line(data = oblist$a, aes(x = DIAMETER, y = bai), color = 'black') +
#     geom_ribbon(data = oblist$a, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'black') +
#     geom_line(data = oblist$b, aes(x = DIAMETER, y = bai), color = 'blue') +
#     geom_ribbon(data = oblist$b, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'blue') +
#     geom_line(data = oblist$c, aes(x = DIAMETER, y = bai), color = 'orange') +
#     geom_ribbon(data = oblist$c, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'orange') +
#     geom_line(data = oblist$d, aes(x = DIAMETER, y = bai), color = 'pink') +
#     geom_ribbon(data = oblist$d, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'pink')
#   return(p)
# }
# plotting_fun(abcde)
# asp = 315, bal = 0.6622384, ba = 40.83743, cr = 0.5

 ######
psmegam1 <- gam(bai~ s(DIAMETER) + s(cr, k = 8) + s(bal.pl.ratio) + s(ba.pl)+
                      s(asp_sin, asp_cos, k = 20) + s(unique_tree_id, bs = 're'),
                    family = 'Gamma'(link = log),
                    data = laoc_psme, method = 'ML')
# laoc_psme$uniq
# 

# asp_sin <- rep(sin(315*(pi/180)), 25)
# asp_cos <- rep(cos(315*(pi/180)), 25)
# bal.pl.ratio <- rep(0.6622384, 25)
# ba.pl <- rep(40.83743, 25)
# cr <- rep(0.5, 25)
# DIAMETER <- (seq(l.u.psme[1], l.u.psme[2], length = 25))
# 
# var.diam.b <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id=laoc.gam$model$unique_tree_id)
# predict(laoc.gam, newdata = var.diam.b, unconditional = T)

#test to see if i type = 'link' then converting is different from type = 'response' #####

# asp_sin <- rep(sin(315*(pi/180)), 25)
# asp_cos <- rep(cos(315*(pi/180)), 25)
# bal.pl.ratio <- rep(0.6622384, 25)
# ba.pl <- rep(40.83743, 25)
# cr <- rep(0.5, 25)
# DIAMETER <- (seq(l.u.laoc[1], l.u.laoc[2], length = 25))
# 
# var.diam.a <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id=sample(laoc.gam$model$unique_tree_id, 25))
# abc <- predict(laoc.gam, newdata = var.diam.a, type = 'link', se.fit = T, exclude = 's(unique_tree_id)', unconditional = T)
# list(laoc.gam$family$linkinv(abc$fit), laoc.gam$family$linkinv(abc$se.fit))
# (bcd <- predict(laoc.gam, newdata = var.diam.a, type = 'response', se.fit = T, exclue = 's(unique_tree_id)', unconditional = T))
# 
# cde <- plot.gam(laoc.gam, seWithMean = T, select = 1)
# def <- plot.gam(laoc.gam, select = 1)
# str(cde)
# 
# efg <- compare_smooths(laoc.gam, pico.gam, psme.gam, pien.gam)
# draw(efg)
# fgh <- compare_smooths(laoc.gam, pico.gam, psme.gam, pien.gam, overall_uncertainty = T)
# draw(fgh)
# 
# lapply(mod.list, summary.gam)
#checking to see if I can get lpmatrix #####
# bai.diam.b <- predict(psme.gam, newdata = var.diam.b, type = 'lpmatrix')
# bai.diam.b1 <- predict(psme.gam, newdata = var.diam.b, type = 'link', se.fit = T, unconditional = T)
# 
# plot.gam(psme.gam, select = 1)
# plot.gam(psmegam1, select = 1)
# 
# aaaaa <- compare_smooths(psme.gam, psmegam1, smooths = 's(DIAMETER)')
# draw(aaaaa)
# 
# psme.gam$Vp == vcov.gam(psme.gam)
# 
# 
# bai.diam.b
# bai.diam.b1
# 
# plot.gam(psmegam1, select = 1)
# plot.gam(psmegam1, select = 1, unconditional = T)
# 
# 
# b <- tibble(var.diam.b, bai = as.vector(bai.diam.b$fit), 
#             se = as.vector(bai.diam.b$se.fit),
#             whichmix=rep('doug-fir', 25))
# 
# b1 <- tibble(var.diam.b, bai = as.vector(bai.diam.b1$fit), 
#             se = as.vector(bai.diam.b$se.fit),
#             whichmix=rep('doug-fir', 25))

#whoops #####
    # #diameter function
  # DIAMETER <- (seq(l.u.laoc[1], l.u.laoc[2], length = 25))
  # var.diam.a <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
  # bai.diam.a <- predict(laoc.gam, newdata = var.diam.a, type = 'response', se.fit = T)
  # a <- tibble(var.diam.a, bai = as.vector(bai.diam.a$fit), 
  #             se = as.vector(bai.diam.a$se.fit),
  #             whichmix=rep('larch', 25))
  #repeat for psme
  # DIAMETER <- (seq(l.u.psme[1], l.u.psme[2], length = 25))
  # var.diam.b <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
  # bai.diam.b <- predict(psme.gam, newdata = var.diam.b, type = 'response', se.fit = T)
  # b <- tibble(var.diam.b, bai = as.vector(bai.diam.b$fit), 
  #             se = as.vector(bai.diam.b$se.fit),
  #             whichmix=rep('doug-fir', 25))
  # #repeat for pico
  # DIAMETER <- (seq(l.u.pico[1], l.u.pico[2], length = 25))
  # var.diam.c <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
  # bai.diam.c <- predict(pico.gam, newdata = var.diam.c, type = 'response', se.fit = T)
  # c <- tibble(var.diam.c, bai = as.vector(bai.diam.c$fit), 
  #             se = as.vector(bai.diam.c$se.fit),
  #             whichmix=rep('lodgepole', 25))
  # #repeat for pien
  # DIAMETER <- (seq(l.u.pien[1], l.u.pien[2], length = 25))
  # var.diam.d <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
  # bai.diam.d <- predict(pien.gam, newdata = var.diam.d, type = 'response', se.fit = T)
  # d <- tibble(var.diam.d, bai = as.vector(bai.diam.d$fit), 
  #             se = as.vector(bai.diam.d$se.fit),
  #             whichmix=rep('e.spruce', 25))
```

```{r}

# ilink <- function(prediction){
#   prediction$fit <- exp(prediction$fit)
#   prediction$se.fit <- exp(prediction$se)
#   return(prediction)
# }
# 
# diam_fun <- function(asp = 315, bal = 0.6622384, ba = 40.83743, cr = 0.5){
#   asp_sin <- rep(sin(asp*(pi/180)), 25)
#   asp_cos <- rep(cos(asp*(pi/180)), 25)
#   bal.pl.ratio <- rep(bal, 25)
#   ba.pl <- rep(ba, 25)
#   cr <- rep(cr, 25)
#   
#   unique_tree_id <- rep(sample(laoc.gam$model$unique_tree_id, 1), 25)
#   #diameter function
#   DIAMETER <- (seq(l.u.laoc[1], l.u.laoc[2], length = 25))
#   var.diam.a <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
#   bai.diam.a <- predict(laoc.gam, newdata = var.diam.a, type = 'link', se.fit = T, exclude = 's(unique_tree_id)')
#   ilink(bai.diam.a)
#   a <- tibble(var.diam.a, bai = as.vector(bai.diam.a$fit), 
#               se = as.vector(bai.diam.a$se.fit),
#               whichmix=rep('larch', 25))
#   #repeat for psme
#   unique_tree_id <- rep(sample(psme.gam$model$unique_tree_id, 1), 25)
#   DIAMETER <- (seq(l.u.psme[1], l.u.psme[2], length = 25))
#   var.diam.b <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
#   bai.diam.b <- predict(psme.gam, newdata = var.diam.b, type = 'response', se.fit = T, exclude = 's(unique_tree_id)')
#   ilink <- bai.diam.b
#   b <- tibble(var.diam.b, bai = as.vector(bai.diam.b$fit), 
#               se = as.vector(bai.diam.b$se.fit),
#               whichmix=rep('doug-fir', 25))
#   #repeat for pico
#   unique_tree_id <- rep(sample(pico.gam$model$unique_tree_id, 1), 25)
#   DIAMETER <- (seq(l.u.pico[1], l.u.pico[2], length = 25))
#   var.diam.c <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
#   bai.diam.c <- predict(pico.gam, newdata = var.diam.c, type = 'response', se.fit = T, exclude = 's(unique_tree_id)')
#   ilink(bai.diam.c)
#   c <- tibble(var.diam.c, bai = as.vector(bai.diam.c$fit), 
#               se = as.vector(bai.diam.c$se.fit),
#               whichmix=rep('lodgepole', 25))
#   #repeat for pien
#   unique_tree_id <- rep(sample(pien.gam$model$unique_tree_id, 1), 25)
#   DIAMETER <- (seq(l.u.pien[1], l.u.pien[2], length = 25))
#   var.diam.d <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos, unique_tree_id)
#   bai.diam.d <- predict(pien.gam, newdata = var.diam.d, type = 'response', se.fit = T, exclude = 's(unique_tree_id)')
#   ilink(bai.diam.d)
#   d <- tibble(var.diam.d, bai = as.vector(bai.diam.d$fit), 
#               se = as.vector(bai.diam.d$se.fit),
#               whichmix=rep('e.spruce', 25))
#   
#   thing <- rbind(a, b, c, d)
#   return(thing)
# }
```


```{r plots}

only.dbh.varies <- diam_fun.a()
plotting_fun(only.dbh.varies) + labs(x = 'DBH', y = 'BAI')
only.dbh.varies

# ba#####

ba.values <- c(50, 100, 150, 200)
for(i in ba.values){
  a <- diam_fun(ba = i)
  nam <- paste('ba.',i,sep = "")
  pl <- plotting_fun(a) + labs(title = nam, x = 'DBH', y = 'BAI')
  assign(nam, pl)
  nam.pairs <- paste('pairs.ba.', i, sep="")
  pl.pairs <- plotting_fun.pairs(a) + labs(title = nam, x = 'DBH', y = 'BAI')
  assign(nam.pairs, pl.pairs)
}
ggarrange(ba.50, ba.100, ba.150, ba.200, 
          nrow = 2, ncol = 2, 
          common.legend = T, legend = 'bottom')
pairs.ba.50
pairs.ba.100
pairs.ba.150
pairs.ba.200

ba.values <- c(50, 100, 150, 200)
for(i in ba.values){
  a <- diam_fun.a(ba = i)
  nam <- paste('ba.',i,sep = "")
  pl <- plotting_fun(a, ylims = c(0, 2.5), y.brks = seq(0, 2.5, 0.25)) + labs(title = nam, x = 'DBH', y = 'BAI')
  assign(nam, pl)
  nam.pairs <- paste('pairs.ba.', i, sep="")
  pl.pairs <- plotting_fun.pairs(a, ylims = c(0, 2.5), y.brks = seq(0, 2.5, 0.25)) + labs(title = nam, x = 'DBH', y = 'BAI')
  assign(nam.pairs, pl.pairs)
}
ggarrange(ba.50, ba.100, ba.150, ba.200, 
          nrow = 2, ncol = 2, 
          common.legend = T, legend = 'bottom')
pairs.ba.50
pairs.ba.100
pairs.ba.150
pairs.ba.200

#bal ######
bal.values <- seq(0,1,0.2)
for(i in bal.values){
  a <- diam_fun(bal = i)
  nam <- paste('bal.',i,sep = "")
  pl <- plotting_fun(a) + labs(title = nam, x = 'DBH', y = 'BAI')
  assign(nam, pl)
}
ggarrange(bal.0, bal.0.2, bal.0.4, bal.0.6, bal.0.8, bal.1, 
          nrow = 2, ncol = 3, 
          common.legend = T, legend = 'bottom')

cr.values <- c(0.1, 0.25, 0.5, 0.75, 0.95)
for(i in cr.values){
  a <- diam_fun(cr = i)
  nam <- paste('cr.',i,sep = "")
  pl <- plotting_fun(a) + labs(title = nam, x = 'DBH', y = 'BAI')
  assign(nam, pl)
}
ggarrange(cr.0.1, cr.0.25, cr.0.5, cr.0.75, cr.0.95, 
          nrow = 2, ncol = 3, 
          common.legend = T, legend = 'bottom')

asp.values <- c(270, 315, 0, 45, 90)
for(i in asp.values){
  a <- diam_fun(asp = i)
  nam <- paste('asp.',i,sep = "")
  pl <- plotting_fun(a) + labs(title = nam, x = 'DBH', y = 'BAI')
  assign(nam, pl)
}
ggarrange(asp.270, asp.315, asp.0, asp.45, asp.90, 
          nrow = 2, ncol = 3, 
          common.legend = T, legend = 'bottom')
```

```{r}
#simulated data
#varying diameter values - everything else constant

####Constants####

###aspect###
# aspects <- c(unique(laoc_laoc$aspect_deg), unique(laoc_pico$aspect_deg), unique(laoc_psme$aspect_deg), unique(laoc_pien$aspect_deg))
# asp_s <- c(unique(laoc_laoc$asp_sin), unique(laoc_pico$asp_sin), unique(laoc_psme$asp_sin), unique(laoc_pien$asp_sin))
# asp_c <- c(unique(laoc_laoc$asp_cos), unique(laoc_pico$asp_cos), unique(laoc_psme$asp_cos), unique(laoc_pien$asp_cos))
# asp_s <- sort(asp_s)
# asp_c <- sort(asp_c)
# # median(asp_s)
# # median(asp_c)
# # mean(asp_s)
# # mean(asp_c)
# 
# aspects <- sort(aspects)
# # plot(asp_c, asp_s)
# aspects <- sort(aspects)
# summary(aspects)
# median(aspects)
# #do they fall within the same range? (NW, NE, SE, SW)
# ggplot() + geom_point(data = laoc_laoc, aes(y = asp_cos, x = asp_sin), color = 'black') +
#   geom_point(data = laoc_psme, aes(y = asp_cos, x = asp_sin), color = 'blue') +
#   geom_point(data = laoc_pico, aes(y = asp_cos, x = asp_sin), color = 'orange') +
#   geom_point(data = laoc_pien, aes(y = asp_cos, x = asp_sin), color = 'pink') + 
#   geom_point(data = NULL, aes(x = sin(315*(pi/180)), y = cos(315*(pi/180))), size = 5)
####
#chose 315 because it's somewhat in between. Could look at N-NW, N, N-NE and compare? 
# asp_sin <- rep(sin(315*(pi/180)), 25)
# asp_cos <- rep(cos(315*(pi/180)), 25)

##CR###

# crs <- c(unique(laoc_laoc$cr), unique(laoc_pico$cr), unique(laoc_psme$cr), unique(laoc_pien$cr))
# crs <- sort(crs)
# unique(crs)
# median(crs)
# cr <- rep(median(crs, na.rm = T), 25)

#BAL#

bals <- c(unique(laoc_laoc$bal.pl.ratio), unique(laoc_pico$bal.pl.ratio), unique(laoc_psme$bal.pl.ratio), unique(laoc_pien$bal.pl.ratio))
bals <- sort(bals)
# median(bals)

bal.pl.ratio <- rep(median(bals, na.rm = T), 25)
summary(bals)
#BA#

bas <- c(unique(laoc_laoc$ba.pl), unique(laoc_pico$ba.pl), unique(laoc_psme$ba.pl), unique(laoc_pien$ba.pl))
bas <- sort(bas)
# median(bas)
hist(bas)
ba.pl <- rep(median(bas, na.rm = T), 25)


#####

asp_sin <- rep(sin(315*(pi/180)), 25)
asp_cos <- rep(cos(315*(pi/180)), 25)
crs <- c(unique(laoc_laoc$cr), unique(laoc_pico$cr), unique(laoc_psme$cr), unique(laoc_pien$cr))
crs <- sort(crs)
cr <- rep(median(crs, na.rm = T), 25)
bals <- c(unique(laoc_laoc$bal.pl.ratio), unique(laoc_pico$bal.pl.ratio), unique(laoc_psme$bal.pl.ratio), unique(laoc_pien$bal.pl.ratio))
bals <- sort(bals)
bal.pl.ratio <- rep(median(bals, na.rm = T), 25)
bas <- c(unique(laoc_laoc$ba.pl), unique(laoc_pico$ba.pl), unique(laoc_psme$ba.pl), unique(laoc_pien$ba.pl))
bas <- sort(bas)
ba.pl <- rep(median(bas, na.rm = T), 25)


plot.list[[50]]
plot.list

#####
#generate diameter ranges for lower quartile to upper quartile
DIAMETER <- (seq(l.u.laoc[1], l.u.laoc[2], length = 25))
var.diam.a <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
bai.diam.a <- predict(laoc.gam, newdata = var.diam.a, type = 'response', se.fit = T)
a <- tibble(var.diam.a, bai = as.vector(bai.diam.a$fit), se = as.vector(bai.diam.a$se.fit))
# aaa <- smooth_estimates(laoc.gam, data = var.diam.a, smooth = 's(DIAMETER)')


#repeat for psme
DIAMETER <- (seq(l.u.psme[1], l.u.psme[2], length = 25))
var.diam.b <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
bai.diam.b <- predict(psme.gam, newdata = var.diam.b, type = 'response', se.fit = T)
b <- tibble(var.diam.b, bai = as.vector(bai.diam.b$fit), se = as.vector(bai.diam.b$se.fit))

#repeat for pico
DIAMETER <- (seq(l.u.pico[1], l.u.pico[2], length = 25))
var.diam.c <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
bai.diam.c <- predict(pico.gam, newdata = var.diam.c, type = 'response', se.fit = T)
c <- tibble(var.diam.c, bai = as.vector(bai.diam.c$fit), se = as.vector(bai.diam.c$se.fit))

#repeat for pien
DIAMETER <- (seq(l.u.pien[1], l.u.pien[2], length = 25))
var.diam.d <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
bai.diam.d <- predict(pien.gam, newdata = var.diam.d, type = 'response', se.fit = T)
d <- tibble(var.diam.d, bai = as.vector(bai.diam.d$fit), se = as.vector(bai.diam.d$se.fit))

rm(DIAMETER)
ggplot() + geom_line(data = a, aes(x = DIAMETER, y = bai), color = 'black') + 
  geom_ribbon(data = a, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'black') +
  geom_line(data = b, aes(x = DIAMETER, y = bai), color = 'blue') + 
  geom_ribbon(data = b, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'blue') +
  geom_line(data = c, aes(x = DIAMETER, y = bai), color = 'orange') +
  geom_ribbon(data = c, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'orange') +
  geom_line(data = d, aes(x = DIAMETER, y = bai), color = 'pink') +
  geom_ribbon(data = d, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'pink')


```

```{r varying ba}
#varying BA
#constants
#diameter is derived by first taking the man of each lower and upper quartile values, and then averaging them all. 
DIAMETER <- rep(4.4, 25)
asp_sin <- rep(sin(315*(pi/180)), 25)
asp_cos <- rep(cos(315*(pi/180)), 25)
bal.pl.ratio <- rep(median(bals, na.rm = T), 25)
cr <- rep(median(crs, na.rm = T), 25)

#basal areas
summary(laoc_psme$ba.pl)
bp.psme <- boxplot(laoc_psme$ba.pl, plot = F)
l.u.psme <- bp.psme$stats[c(2, 4)]
bp.laoc <- boxplot(laoc_laoc$ba.pl, plot = F)
l.u.laoc <- bp.laoc$stats[c(2,4)]
bp.pico <- boxplot(laoc_pico$ba.pl, plot = F)
l.u.pico <- bp.pico$stats[c(2, 4)]
bp.pien <- boxplot(laoc_pien$ba.pl, plot = F)
l.u.pien <- bp.pien$stats[c(2, 4)]

#first try basal areas varying between 0 and 150
# ba.pl <- seq(l.u.laoc[1], l.u.laoc[2], length = 25)
ba.pl <- seq(20, 150, length = 25)
var.ba <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)

bai.ba.a <- predict(laoc.gam, newdata = var.ba, type = 'response', se.fit = T)
aa <- tibble(var.ba, bai = as.vector(bai.ba.a$fit), se = as.vector(bai.ba.a$se.fit))

bai.ba.b <- predict(psme.gam, newdata = var.ba, type = 'response', se.fit = T)
bb <- tibble(var.ba, bai = as.vector(bai.ba.b$fit), se = as.vector(bai.ba.b$se.fit))

bai.ba.c <- predict(pico.gam, newdata = var.ba, type = 'response', se.fit = T)
cc <- tibble(var.ba, bai = as.vector(bai.ba.c$fit), se = as.vector(bai.ba.c$se.fit))

bai.ba.d <- predict(pien.gam, newdata = var.ba, type = 'response', se.fit = T)
dd <- tibble(var.ba, bai = as.vector(bai.ba.d$fit), se = as.vector(bai.ba.d$se.fit))

rm(ba.pl)
ggplot() + geom_line(data = aa, aes(x = ba.pl, y = bai), color = 'black') + 
  geom_ribbon(data = aa, aes(x = ba.pl, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'black') +
  geom_line(data = bb, aes(x = ba.pl, y = bai), color = 'blue') + 
  geom_ribbon(data = bb, aes(x = ba.pl, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'blue') +
  geom_line(data = cc, aes(x = ba.pl, y = bai), color = 'orange') +
  geom_ribbon(data = cc, aes(x = ba.pl, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'orange') +
  geom_line(data = dd, aes(x = ba.pl, y = bai), color = 'pink') +
  geom_ribbon(data = dd, aes(x = ba.pl, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'pink')
```

```{r varying bal}
#varying BAL
DIAMETER <- rep(4.4, 25)
asp_sin <- rep(sin(315*(pi/180)), 25)
asp_cos <- rep(cos(315*(pi/180)), 25)
cr <- rep(median(crs, na.rm = T), 25)
bas <- c(unique(laoc_laoc$ba.pl), unique(laoc_pico$ba.pl), unique(laoc_psme$ba.pl), unique(laoc_pien$ba.pl))
bas <- sort(bas)
ba.pl <- rep(median(bas, na.rm = T), 25)

bal.pl.ratio <- seq(0 ,1 ,length = 25)
var.bal <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)

bai.bal.a <- predict(laoc.gam, newdata = var.bal, type = 'response', se.fit = T)
aa <- tibble(var.bal, bai = as.vector(bai.bal.a$fit), se = as.vector(bai.bal.a$se.fit))

bai.bal.b <- predict(psme.gam, newdata = var.bal, type = 'response', se.fit = T)
bb <- tibble(var.bal, bai = as.vector(bai.bal.b$fit), se = as.vector(bai.bal.b$se.fit))

bai.bal.c <- predict(pico.gam, newdata = var.bal, type = 'response', se.fit = T)
cc <- tibble(var.bal, bai = as.vector(bai.bal.c$fit), se = as.vector(bai.bal.c$se.fit))

bai.bal.d <- predict(pien.gam, newdata = var.bal, type = 'response', se.fit = T)
dd <- tibble(var.bal, bai = as.vector(bai.bal.d$fit), se = as.vector(bai.bal.d$se.fit))


ggplot() + geom_line(data = aa, aes(x = bal.pl.ratio, y = bai), color = 'black') + 
  geom_ribbon(data = aa, aes(x = bal.pl.ratio, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'black') +
  geom_line(data = bb, aes(x = bal.pl.ratio, y = bai), color = 'blue') + 
  geom_ribbon(data = bb, aes(x = bal.pl.ratio, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'blue') +
  geom_line(data = cc, aes(x = bal.pl.ratio, y = bai), color = 'orange') +
  geom_ribbon(data = cc, aes(x = bal.pl.ratio, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'orange') +
  geom_line(data = dd, aes(x = bal.pl.ratio, y = bai), color = 'pink') +
  geom_ribbon(data = dd, aes(x = bal.pl.ratio, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'pink')

```

```{r}
#varying crown ratio

DIAMETER <- rep(4.4, 25)
asp_sin <- rep(sin(315*(pi/180)), 25)
asp_cos <- rep(cos(315*(pi/180)), 25)
#cr <- rep(median(crs, na.rm = T), 25)
bas <- c(unique(laoc_laoc$ba.pl), unique(laoc_pico$ba.pl), unique(laoc_psme$ba.pl), unique(laoc_pien$ba.pl))
bas <- sort(bas)
ba.pl <- rep(median(bas, na.rm = T), 25)
bal.pl.ratio <- rep(median(bals, na.rm = T), 25)

cr <- seq(.1,1,length=25)
var.cr <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)

bai.cr.a <- predict(laoc.gam, newdata = var.cr, type = 'response', se.fit = T)
aaa <- tibble(var.cr, bai = as.vector(bai.cr.a$fit), se = as.vector(bai.cr.a$se.fit))

bai.cr.b <- predict(psme.gam, newdata = var.cr, type = 'response', se.fit = T)
bbb <- tibble(var.cr, bai = as.vector(bai.cr.b$fit), se = as.vector(bai.cr.b$se.fit))

bai.cr.c <- predict(pico.gam, newdata = var.cr, type = 'response', se.fit = T)
ccc <- tibble(var.cr, bai = as.vector(bai.cr.c$fit), se = as.vector(bai.cr.c$se.fit))

bai.cr.d <- predict(pien.gam, newdata = var.cr, type = 'response', se.fit = T)
ddd <- tibble(var.cr, bai = as.vector(bai.cr.d$fit), se = as.vector(bai.cr.d$se.fit))


ggplot() + geom_line(data = aaa, aes(x = cr, y = bai), color = 'black') + 
  geom_ribbon(data = aaa, aes(x = cr, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'black') +
  geom_line(data = bbb, aes(x = cr, y = bai), color = 'blue') + 
  geom_ribbon(data = bbb, aes(x = cr, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'blue') +
  geom_line(data = ccc, aes(x = cr, y = bai), color = 'orange') +
  geom_ribbon(data = ccc, aes(x = cr, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'orange') +
  geom_line(data = ddd, aes(x = cr, y = bai), color = 'pink') +
  geom_ribbon(data = ddd, aes(x = cr, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'pink')
```



```{r data slice, include = F}
#try out data slice
#create data frame with one value for psme
DIAMETER <- 4.4
asp_sin <- sin(315*(pi/180))
asp_cos <- cos(315*(pi/180))
cr <- median(crs, na.rm = T)
bas <- c(unique(laoc_laoc$ba.pl), unique(laoc_pico$ba.pl), unique(laoc_psme$ba.pl), unique(laoc_pien$ba.pl))
bas <- sort(bas)
ba.pl <- median(bas, na.rm = T)

bal.test <- data.frame(DIAMETER, asp_sin, asp_cos, cr, ba.pl)

bal.pred.data <- data_slice(psme.gam, 'bal.pl.ratio', data = bal.test, n = 25)
pred <- predict(psme.gam, newdata = bal.pred.data, type = 'link', se.fit = T)
pred <- as.data.frame(pred)
ilink <- family(psme.gam)$linkinv
dddd <- family(psme.gam)
dddd$linkinv(pred$fit)
exp(pred$fit)
pred <- transform(pred,
                  bai = ilink(fit),
                  upr = ilink(fit+se.fit),
                  lwr = ilink(fit-se.fit),
                  bal.pl.ratio=bal.pred.data$bal.pl.ratio)
vals <- bal.pred.data[,2:7]
bal.pr <- tibble(vals, pred)


#laoc
bal.pred.data_l <- data_slice(laoc.gam, 'bal.pl.ratio', data = bal.test, n = 25)
p1 <- predict(laoc.gam, newdata = bal.pred.data_l, type = 'link', se.fit = T)
p1 <- as.data.frame(p1)
p1 <- transform(p1,
                bai = ilink(fit),
                upr = ilink(fit + se.fit),
                lwr = ilink(fit - se.fit),
                bal.pl.ratio = bal.pred.data_l$bal.pl.ratio)
v1 <- bal.pred.data_l[,2:7]
bal.llll <- tibble(v1, p1)

ggplot() + geom_line(data = bal.pr, aes(x = bal.pl.ratio, y = bai)) + geom_ribbon(data = bal.pr, aes(x = bal.pl.ratio, ymin = lwr, ymax = upr), alpha = 0.2, fill = 'blue') + geom_line(data = bal.llll, aes(x = bal.pl.ratio, y = bai), color = 'black') + 
  geom_ribbon(data = bal.llll, aes(x = bal.pl.ratio, ymin = lwr, ymax = upr), alpha = 0.2, fill = 'black')
ggplot() + geom_line(data = aa, aes(x = bal.pl.ratio, y = bai), color = 'black') + 
  geom_ribbon(data = aa, aes(x = bal.pl.ratio, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'black') +
  geom_line(data = bb, aes(x = bal.pl.ratio, y = bai), color = 'blue') + 
  geom_ribbon(data = bb, aes(x = bal.pl.ratio, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'blue')


var.bal
bal.pred.data

```

