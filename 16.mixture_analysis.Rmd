---
title: "different_mixtures"
author: "Christian Mercado"
date: '2022-07-20'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#readin
library(gratia)
library(tidyverse)
library(mgcv)
library(gridExtra)
source('12.gam_fns.R')

hab_loc_codes <- read_csv('data/habtypes.csv')
hab_loc_codes <- hab_loc_codes %>% select(SETTING_ID, habclass, locationcode)
bai.train <- readRDS('data/bai.train.7_14_22.rds')
bai.train <- left_join(bai.train, hab_loc_codes, by = "SETTING_ID")

bai.spmx <- bai.train %>% 
  select(SETTING_ID, stand, MEASUREMENT_NO, myear, PLOT, cluster, unique_tree_id, 
         bai, DIAMETER, treeba, log.diam, log.bai, grwth.yr, mean_si, aspect_deg, 
         heatload, slope_deg, elev_m, NF, CROWN_RATIO, tpa.pl.all, tpa.pl.cutoff,
         ba.pl, bal.pl, ccf.pl, ccf.nospp, qmd.pl.all, qmd.pl.cutoff, dq.pl.all, 
         dq.pl.cutoff, tpa.cl.all, tpa.pl.cutoff,
         ba.cl, ccf.cl, bal.cl, dq.cl.all, dq.cl.cutoff, HabType, habclass,
         locationcode, percent_LAOC, shade.tol.pl, dom.spp.pl.ba, percent_PSME, 
         percent_PIEN, percent_ABLA, percent_ABGR, percent_PICO, percent_PIPO, percent_other) %>% 
  mutate(slope_pct = tan(slope_deg*(pi/180))*100, 
         asp_sin = sin(aspect_deg*(pi/180)),
         asp_cos = cos(aspect_deg*(pi/180))) %>%
  mutate(sl_asp_sin = asp_sin*slope_pct, 
         sl_asp_cos = asp_cos*slope_pct, 
         asp.trasp = trasp(aspect_deg), 
         HabType = as.factor(HabType),
         cr = CROWN_RATIO/100,
         bal.pl.ratio = bal.pl/ba.pl,
         unique_tree_id = factor(unique_tree_id)) %>% 
  filter(bai != 0)


bai.spmx.ids <- bai.spmx %>% 
  group_by(stand) %>% 
  mutate(unique.stand = cur_group_id()) %>%
  ungroup() %>% 
  mutate(unique.cluster = (1000*unique.stand)+cluster, 
         unique.plot = (1000*unique.stand)+PLOT) %>% 
  mutate(unique.cluster.meas = as.factor(unique.cluster + MEASUREMENT_NO), 
         unique.plot.meas = as.factor(unique.plot + MEASUREMENT_NO),
         unique.cluster.f = as.factor(unique.cluster), 
         unique.plot.f = as.factor(unique.plot), 
         unique.tree.f = as.factor(unique_tree_id)) %>% 
  filter(unique_tree_id != 15431)

#null model to compare to for results
#re.tree.1alt <- readRDS('data/model_objects.1/re.tree.1alt.rds')
#larch fraction - alternative with random 
# spmx.gam.alt.lf <- readRDS('data/model_objects.1/spmx.gam.alt.lf_7.11.rds')
#shade tol - alternative with random
# spmx.gam.alt.st <- readRDS('data/model_objects.1/spmx.gam.alt.st.rds')
```

```{r}
# metric cateogrizing larch with each other species
# larch.mixtures <- function(data, species, maximum, combined_min){
#   a <- data %>% filter(percent_LAOC < maximum & '{species}' < maximum & (percent_LAOC+'{species}') > combined_min)
#   return(a)
# }
# bai.spmx.ids %>% filter(percent_LAOC>0.4 & percent_PSME>0.4 & (percent_LAOC+percent_PSME)>0.6)

# larch.mixtures(bai.spmx.ids, percent_PSME, maximum = 0.8, combined_min =.4)

spp.fun <- function(spp_min, spp_maximum, combined_min){
  a <- bai.spmx.ids %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_PSME<spp_maximum & percent_PSME>spp_min, 
                               (percent_LAOC+percent_PSME)>combined_min)
  b <- bai.spmx.ids %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_ABLA<spp_maximum & percent_ABLA>spp_min, 
                               (percent_LAOC+percent_ABLA)>combined_min)
  c <- bai.spmx.ids %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_ABGR<spp_maximum & percent_ABGR>spp_min, 
                               (percent_LAOC+percent_ABGR)>combined_min)
  d <- bai.spmx.ids %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_PIEN<spp_maximum & percent_PIEN>spp_min, 
                               (percent_LAOC+percent_PIEN)>combined_min)
  e <- bai.spmx.ids %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_PICO<spp_maximum & percent_PICO>spp_min, 
                               (percent_LAOC+percent_PICO)>combined_min)
  f <- bai.spmx.ids %>% filter(percent_LAOC<spp_maximum & percent_LAOC>spp_min, 
                               percent_PIPO<spp_maximum & percent_PIPO>spp_min, 
                               (percent_LAOC+percent_PIPO)>combined_min)
  g <- bai.spmx.ids %>% filter(percent_LAOC>combined_min)
   return(list('psme'=a, 'abla'=b, 'abgr'=c, 'pien'=d, 'pico'=e, 'pipo'=f, 'laoc' = g))
  }
(mixtures <- spp.fun(0.2, .65, 0.7))
individual.obs <- lapply(mixtures, function(x)
  length(unique(x$unique_tree_id)))
(dbh.plots <- lapply(mixtures, function(m)
  p <- ggplot(m, aes(x = DIAMETER)) + geom_histogram()))
(dens.plots <- lapply(mixtures, function(m)
  p <- ggplot(m, aes(x = ba.pl)) + geom_histogram()))
(bai.plots <- lapply(mixtures, function(m)
  p <- ggplot(m, aes(x = bai)) + geom_histogram()))



data.frame(unlist(individual.obs))
```

```{r}
#fit gams for subsets of data
laoc_psme <- mixtures$psme
hist(laoc_psme$bai)
length(unique(laoc_psme$asp_sin))
ggplot(laoc_psme, aes(x = percent_LAOC, y = percent_PSME)) + geom_point()
psme.gam <- gamm(bai~ s(DIAMETER) + s(cr, k = 8) + s(bal.pl.ratio) + s(ba.pl)+
                      s(asp_sin, asp_cos, k = 20),
                    random=list(unique_tree_id=~1),
                    family = 'Gamma'(link = log),
                    data = laoc_psme, method = 'ML')
# med.psme <- median(laoc_psme)
summary(laoc_psme$DIAMETER)
bp.psme <- boxplot(laoc_psme$DIAMETER, plot = F)
l.u.psme <- bp.psme$stats[c(2, 4)]


laoc_pico <- mixtures$pico
length(unique(laoc_pico$cr))
hist(laoc_pico$bai)
plot(laoc_pico$DIAMETER, laoc_pico$bai)
filter(laoc_pico, bai>3)
ggplot(laoc_pico, aes(x = percent_LAOC, y = percent_PICO)) + geom_point()
pico.gam <- gamm(bai~ s(DIAMETER) + s(cr, k = 7) + s(bal.pl.ratio) + s(ba.pl)+
                      s(asp_sin, asp_cos, k = 13),
                    random=list(unique_tree_id=~1),
                    family = 'Gamma'(link = log),
                    data = laoc_pico, method = 'ML')


laoc_laoc <- mixtures$laoc
length(unique(laoc_laoc$asp_sin))
laoc.gam <- gamm(bai~ s(DIAMETER) + s(cr, k = 9) + s(bal.pl.ratio) + s(ba.pl)+
                      s(asp_sin, asp_cos, k = 20),
                    random=list(unique_tree_id=~1),
                    family = 'Gamma'(link = log),
                    data = laoc_laoc, method = 'ML')

laoc_pien <- mixtures$pien
ggplot(laoc_pien, aes(x = percent_LAOC, y = percent_PIEN)) + geom_point()
length(unique(laoc_pien$asp_sin))
length(unique(laoc_pien$cr))
pien.gam <- gamm(bai~ s(DIAMETER) + s(cr, k = 8) + s(bal.pl.ratio) + s(ba.pl)+
                      s(asp_sin, asp_cos, k = 8),
                    random=list(unique_tree_id=~1),
                    family = 'Gamma'(link = log),
                    data = laoc_pien, method = 'ML')

mod.list <- list(psme.gam$gam, pico.gam$gam, pien.gam$gam, laoc.gam$gam)
lapply(mod.list, gam.check)
# plot(pico.gam$gam)
# filter(bai.spmx.ids, unique_tree_id == 2505)
# bbb <- readRDS('data/bai.shade.rds')
# bbb %>% filter(unique_tree_id == 2505)
# bbb %>% filter(!(unique_tree_id == 2505 & MEASUREMENT_NO == 4))
# rm(data)
plot.gam(mod.list[[1]])
## change bai to 4.611038134
summary(laoc.gam$gam)
summary(pico.gam$gam)
summary(psme.gam$gam)
summary(pien.gam$gam)
for(i in 1:5){
  par(mfrow = c(2,2))
  plot(laoc.gam$gam, residuals = T, trans = exp, select = i, ylim = c(0,4), shift = 0.0228)
  plot(pico.gam$gam, residuals = T, trans = exp, select = i, ylim = c(0,4), shift = -.15581)
  plot(psme.gam$gam, residuals = T, trans = exp, select = i, ylim = c(0,4), shift = -.426596)
  plot(pien.gam$gam, residuals = T, trans = exp, select = i, ylim = c(0,4), shift = 0.38111221)
}


bp.psme <- boxplot(laoc_psme$DIAMETER, plot = F)
l.u.psme <- bp.psme$stats[c(2, 4)]
bp.laoc <- boxplot(laoc_laoc$DIAMETER, plot = F)
l.u.laoc <- bp.laoc$stats[c(2,4)]
bp.pico <- boxplot(laoc_pico$DIAMETER, plot = F)
l.u.pico <- bp.pico$stats[c(2, 4)]
bp.pien <- boxplot(laoc_pien$DIAMETER, plot = F)
l.u.pien <- bp.pien$stats[c(2, 4)]
```

```{r}
#simulated data
#varying diameter values - everything else constant

####Constants####

##aspect##
aspects <- c(unique(laoc_laoc$aspect_deg), unique(laoc_pico$aspect_deg), unique(laoc_psme$aspect_deg), unique(laoc_pien$aspect_deg))
asp_s <- c(unique(laoc_laoc$asp_sin), unique(laoc_pico$asp_sin), unique(laoc_psme$asp_sin), unique(laoc_pien$asp_sin))
asp_c <- c(unique(laoc_laoc$asp_cos), unique(laoc_pico$asp_cos), unique(laoc_psme$asp_cos), unique(laoc_pien$asp_cos))
asp_s <- sort(asp_s)
asp_c <- sort(asp_c)
# median(asp_s)
# median(asp_c)
# mean(asp_s)
# mean(asp_c)

aspects <- sort(aspects)
# plot(asp_c, asp_s)
aspects <- sort(aspects)
# summary(aspects)
# median(aspects)
# #do they fall within the same range? (NW, NE, SE, SW)
# ggplot() + geom_point(data = laoc_laoc, aes(y = asp_cos, x = asp_sin), color = 'black') +
#   geom_point(data = laoc_psme, aes(y = asp_cos, x = asp_sin), color = 'blue') +
#   geom_point(data = laoc_pico, aes(y = asp_cos, x = asp_sin), color = 'orange') +
#   geom_point(data = laoc_pien, aes(y = asp_cos, x = asp_sin), color = 'pink') + 
#   geom_point(data = NULL, aes(x = sin(315*(pi/180)), y = cos(315*(pi/180))), size = 5)

#chose 315 because it's somewhat in between. Could look at N-NW, N, N-NE and compare? 
asp_sin <- rep(sin(315*(pi/180)), 25)
asp_cos <- rep(cos(315*(pi/180)), 25)

##CR##
# ggplot() + geom_point(data = laoc_laoc, aes(x = DIAMETER, y = cr), color = 'black') +
#   geom_point(data = laoc_psme, aes(x = DIAMETER, y = cr), color = 'blue') +
#   geom_point(data = laoc_pico, aes(x = DIAMETER, y = cr), color = 'orange') +
#   geom_point(data = laoc_pien, aes(x = DIAMETER, y = cr), color = 'pink')
crs <- c(unique(laoc_laoc$cr), unique(laoc_pico$cr), unique(laoc_psme$cr), unique(laoc_pien$cr))
crs <- sort(crs)
# unique(crs)
# median(crs)

cr <- rep(median(crs, na.rm = T), 25)

#BAL#
# ggplot() + geom_point(data = laoc_laoc, aes(x = DIAMETER, y = bal.pl.ratio), color = 'black') +
#   geom_point(data = laoc_psme, aes(x = DIAMETER, y = bal.pl.ratio), color = 'blue') +
#   geom_point(data = laoc_pico, aes(x = DIAMETER, y = bal.pl.ratio), color = 'orange') +
#   geom_point(data = laoc_pien, aes(x = DIAMETER, y = bal.pl.ratio), color = 'pink')
bals <- c(unique(laoc_laoc$bal.pl.ratio), unique(laoc_pico$bal.pl.ratio), unique(laoc_psme$bal.pl.ratio), unique(laoc_pien$bal.pl.ratio))
bals <- sort(bals)
# median(bals)

bal.pl.ratio <- rep(median(bals, na.rm = T), 25)
summary(bals)
#BA#
# ggplot() + geom_point(data = laoc_laoc, aes(x = DIAMETER, y = ba.pl), color = 'black') +
#   geom_point(data = laoc_psme, aes(x = DIAMETER, y = ba.pl), color = 'blue') +
#   geom_point(data = laoc_pico, aes(x = DIAMETER, y = ba.pl), color = 'orange') +
#   geom_point(data = laoc_pien, aes(x = DIAMETER, y = ba.pl), color = 'pink')
bas <- c(unique(laoc_laoc$ba.pl), unique(laoc_pico$ba.pl), unique(laoc_psme$ba.pl), unique(laoc_pien$ba.pl))
bas <- sort(bas)
# median(bas)

ba.pl <- rep(median(bas, na.rm = T), 25)

#generate diameter ranges for lower quartile to upper quartile
DIAMETER <- (seq(l.u.laoc[1], l.u.laoc[2], length = 25))
var.diam.a <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
bai.diam.a <- predict(laoc.gam$gam, newdata = var.diam.a, type = 'response', se.fit = T)
a <- tibble(var.diam.a, bai = as.vector(bai.diam.a$fit), se = as.vector(bai.diam.a$se.fit))
# aaa <- smooth_estimates(laoc.gam$gam, data = var.diam.a, smooth = 's(DIAMETER)')


#repeat for psme
DIAMETER <- (seq(l.u.psme[1], l.u.psme[2], length = 25))
var.diam.b <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
bai.diam.b <- predict(psme.gam$gam, newdata = var.diam.b, type = 'response', se.fit = T)
b <- tibble(var.diam.b, bai = as.vector(bai.diam.b$fit), se = as.vector(bai.diam.b$se.fit))

#repeat for pico
DIAMETER <- (seq(l.u.pico[1], l.u.pico[2], length = 25))
var.diam.c <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
bai.diam.c <- predict(pico.gam$gam, newdata = var.diam.c, type = 'response', se.fit = T)
c <- tibble(var.diam.c, bai = as.vector(bai.diam.c$fit), se = as.vector(bai.diam.c$se.fit))

#repeat for pien
DIAMETER <- (seq(l.u.pien[1], l.u.pien[2], length = 25))
var.diam.d <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)
bai.diam.d <- predict(pien.gam$gam, newdata = var.diam.d, type = 'response', se.fit = T)
d <- tibble(var.diam.d, bai = as.vector(bai.diam.d$fit), se = as.vector(bai.diam.d$se.fit))

rm(DIAMETER)
ggplot() + geom_line(data = a, aes(x = DIAMETER, y = bai), color = 'black') + 
  geom_ribbon(data = a, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'black') +
  geom_line(data = b, aes(x = DIAMETER, y = bai), color = 'blue') + 
  geom_ribbon(data = b, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'blue') +
  geom_line(data = c, aes(x = DIAMETER, y = bai), color = 'orange') +
  geom_ribbon(data = c, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'orange') +
  geom_line(data = d, aes(x = DIAMETER, y = bai), color = 'pink') +
  geom_ribbon(data = d, aes(x = DIAMETER, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'pink')

```

```{r}
#varying BA
#constants
#diameter is derived by first taking the man of each lower and upper quartile values, and then averaging them all. 
DIAMETER <- rep(4.4, 25)
asp_sin <- rep(sin(315*(pi/180)), 25)
asp_cos <- rep(cos(315*(pi/180)), 25)
bal.pl.ratio <- rep(median(bals, na.rm = T), 25)
cr <- rep(median(crs, na.rm = T), 25)

#basal areas
summary(laoc_psme$ba.pl)
bp.psme <- boxplot(laoc_psme$ba.pl, plot = F)
l.u.psme <- bp.psme$stats[c(2, 4)]
bp.laoc <- boxplot(laoc_laoc$ba.pl, plot = F)
l.u.laoc <- bp.laoc$stats[c(2,4)]
bp.pico <- boxplot(laoc_pico$ba.pl, plot = F)
l.u.pico <- bp.pico$stats[c(2, 4)]
bp.pien <- boxplot(laoc_pien$ba.pl, plot = F)
l.u.pien <- bp.pien$stats[c(2, 4)]

#first try basal areas varying between 0 and 150
# ba.pl <- seq(l.u.laoc[1], l.u.laoc[2], length = 25)
ba.pl <- seq(20, 150, length = 25)
var.ba <- tibble(DIAMETER, cr, bal.pl.ratio, ba.pl, asp_sin, asp_cos)

bai.ba.a <- predict(laoc.gam$gam, newdata = var.ba, type = 'response', se.fit = T)
aa <- tibble(var.ba, bai = as.vector(bai.ba.a$fit), se = as.vector(bai.ba.a$se.fit))

bai.ba.b <- predict(psme.gam$gam, newdata = var.ba, type = 'response', se.fit = T)
bb <- tibble(var.ba, bai = as.vector(bai.ba.b$fit), se = as.vector(bai.ba.b$se.fit))

bai.ba.c <- predict(pico.gam$gam, newdata = var.ba, type = 'response', se.fit = T)
cc <- tibble(var.ba, bai = as.vector(bai.ba.c$fit), se = as.vector(bai.ba.c$se.fit))

bai.ba.d <- predict(pien.gam$gam, newdata = var.ba, type = 'response', se.fit = T)
dd <- tibble(var.ba, bai = as.vector(bai.ba.d$fit), se = as.vector(bai.ba.d$se.fit))

rm(ba.pl)
ggplot() + geom_line(data = aa, aes(x = ba.pl, y = bai), color = 'black') + 
  geom_ribbon(data = aa, aes(x = ba.pl, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'black') +
  geom_line(data = bb, aes(x = ba.pl, y = bai), color = 'blue') + 
  geom_ribbon(data = bb, aes(x = ba.pl, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'blue') +
  geom_line(data = cc, aes(x = ba.pl, y = bai), color = 'orange') +
  geom_ribbon(data = cc, aes(x = ba.pl, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'orange') +
  geom_line(data = dd, aes(x = ba.pl, y = bai), color = 'pink') +
  geom_ribbon(data = dd, aes(x = ba.pl, ymin = bai-se, ymax = bai+se), alpha = 0.2, fill = 'pink')
```

```{r}
#varying aspect


```

