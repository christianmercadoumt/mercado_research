---
title: "bai.model"
author: "Christian Mercado"
date: "3/1/2022"
output: html_document
---

```{r setup, include=FALSE}

#load packages
library(tidyverse)
library(mgcv)
library(gratia)
library(ggrepel)
library(measurements)

#load data
bai.train <- readRDS('data/bai.train.3_9_22.rds')

bai.size <- bai.train %>% 
  select(stand, MEASUREMENT_NO, PLOT, unique_tree_id, 
         bai, DIAMETER, treeba, log.diam, log.bai, grwth.yr) %>% 
  filter(bai != 0) %>% 
  mutate(bai = conv_unit(bai, 'ft2', 'inch2')) #Convert from sqft/yr to sqinches/yr



## Standard RMSE
my.rmse.gam <- function(gam){
  res <- residuals.gam(gam, type = 'response')
  res.sq <- res^2
  sqrt(mean(res.sq))
}

## RMSE further penalizing models that use more degrees of freedom
my.rmse.dfres <- function(gam){
  res <- residuals.gam(gam, type = 'response')
  res.sq <- res^2
  sqrt(sum(res.sq)/(gam$df.residual))
}

#bai.size.test <- bai.test %>% select(stand, MEASUREMENT_NO, PLOT, unique_tree_id, bai, DIAMETER, HEIGHT, treeba, log.diam, log.bai) %>% filter(bai != 0)

#my.rmse.xval <- function(gam, testdata){
#  prd <- predict.gam(gam, newdata = testdata, type = 'response')
#  data.t <- testdata$bai
#  rmse <- sqrt(mean((prd-data.t)^2))
#  return(rmse)
#}

#create function that creates gam objects, plots, and diagnostics?


```


```{r which distribution, include = FALSE}
hist(bai.size$bai) #gaussian identity link
hist(log(bai.size$bai)) #log-link
hist(sqrt(bai.size$bai)) #sqrt-link (inverse gaussian?)
```
I need to choose whether to include DBH or BA. Probably shouldn't consider height.. although it could improve the model?? The issue is that not every record has a height. 

Gamma with log link is the best.

```{r null model}
#create null model
gam.null <- gam(bai~1, family = 'Gamma'(link = log), data = bai.size)
summary.gam(gam.null)
my.rmse.gam(gam.null)

```

```{r size gam full}
#create full saturated model
gam.size.full <- gam(bai~s(DIAMETER, bs = 'tp') + s(treeba, bs = 'tp'), family = 'Gamma'(link = log), data = bai.size, na.action = 'na.omit')
summary.gam(gam.size.full)
#appraise(gam.size.full)
draw(gam.size.full)
par(mfrow = c(2, 2))
gam.check(gam.size.full)


#gam.size.full1 <- gam(bai~s(DIAMETER, bs = 'tp') + s(HEIGHT, bs = 'cr') + s(treeba, bs = 'tp'), family = 'Gamma'(link = log), data = bai.size, na.action = 'na.omit')
#summary.gam(gam.size.full1)
#appraise(gam.size.full1)
#draw(gam.size.full1)
#par(mfrow = c(2,2))
#gam.check(gam.size.full1)

my.rmse.gam(gam.size.full)
my.rmse.dfres(gam.size.full)

```
Treeba variable has high effective degrees of freedom. perhaps try different fit approach? maybe don't worry about it?


```{r size variables separated}

gam.s1 <- gam(bai~s(DIAMETER), family = 'Gamma'(link = log), data = bai.size)
plot.gam(gam.s1)
par(mfrow = c(2, 2))
gam.check(gam.s1)

my.rmse.gam(gam.s1)
my.rmse.dfres(gam.s1)

par(mfrow = c(1,1))
gam.s3 <- gam(bai~s(treeba), family = 'Gamma'(link = log), data = bai.size)
plot.gam(gam.s3)
par(mfrow = c(2, 2))
gam.check(gam.s3)

my.rmse.gam(gam.s3)
my.rmse.dfres(gam.s3)

```

Overall DBH looks the best and seems to perform better than BA.

```{r exploring resids}
rsd <- residuals.gam(gam.s1, type = 'response')
ft <- gam.s1$fitted.values
id <- seq(1:length(rsd))
stand <- bai.size$grwth.yr
a <- tibble(rsd, ft, id, stand)
a
ggplot(a, aes(ft, rsd, label = id, color = factor(stand>=12))) + geom_point(alpha = .2) + geom_label_repel()
gam.s1$model
filter(bai.size, bai > .0175)

ggplot(bai.size[ft<=.0165,], aes(x = DIAMETER)) + geom_histogram()

### WHATS GOING ON IN RESIDUALS?
#### is it just very large trees??
bai.size[c(26, 111, 2836, 20, 2744, 38, 54, 69, 127),]


```

```{r FVS Size vars}

fvs.size1 <- gam(bai~log.diam + I(DIAMETER^2), family = 'Gamma'(link = log), data = bai.size)

summary.gam(fvs.size1)
my.rmse.gam(fvs.size1)
my.rmse.dfres(fvs.size1)

```

```{r rmse table}
type <- c('rmse', 'rmse.df.resid')
null.gam <- c(my.rmse.gam(gam.null), my.rmse.dfres(gam.null))
size.full <- c(my.rmse.gam(gam.size.full), my.rmse.dfres(gam.size.full))
diam <- c(my.rmse.gam(gam.s1), my.rmse.dfres(gam.s1))
fvs.sz <- c(my.rmse.gam(fvs.size1),my.rmse.dfres(fvs.size1))

tibble(type, null.gam, size.full, diam, fvs.sz)

```


```{r size full reml version, include = FALSE}
gam.size.full <- gam(bai~s(DIAMETER, bs = 'tp') + s(HEIGHT, bs = 'tp') + s(treeba, bs = 'tp'), family = 'Gamma'(link = log), data = bai.size, na.action = 'na.omit', method = 'REML')
summary.gam(gam.size.full)
appraise(gam.size.full)
draw(gam.size.full)

gam.size.full1 <- gam(bai~s(DIAMETER, bs = 'cr') + s(HEIGHT, bs = 'cr') + s(treeba, bs = 'cr'), family = 'Gamma'(link = log), data = bai.size, na.action = 'na.omit', method = 'REML')
summary.gam(gam.size.full1)
appraise(gam.size.full1)
draw(gam.size.full1)

my.rmse.gam(gam.size.full)
my.rmse.gam(gam.size.full1)
```



```{r, include = FALSE}
s1 <- gam(bai~s(DIAMETER), data = bai.size, family = 'Gamma'(link = log))
#s1a <- gam(bai~s(DIAMETER), data = bai.size, family = 'gaussian'(link = log))
#s1b <- gam(bai~s(DIAMETER), data = bai.size, family = 'inverse.gaussian'(link = log))
#s1c <- gam(bai~s(DIAMETER), data = bai.size, family = 'inverse.gaussian'(link = 1/mu^2))

s2 <- gam(bai~s(treeba), data = bai.size, family = 'Gamma'(link = log))
#s1a <- gam(bai~s(BASAL_AREA_EQUIV.pl), data = bai.size, family = 'gaussian'(link = log))
#s1b <- gam(bai~s(BASAL_AREA_EQUIV.pl), data = bai.size, family = 'inverse.gaussian'(link = log))
#s1c <- gam(bai~s(BASAL_AREA_EQUIV.pl), data = bai.size, family = 'inverse.gaussian'(link = 1/mu^2))

plot.gam(s1)
plot.gam(s2)
#plot.gam(s1a)
#plot.gam(s1b)
#plot.gam(s1c)

AIC(s1)
AIC(s2)
#AIC(s1a)
#AIC(s1b)
#AIC(s1c)

appraise(s1)
appraise(s2)
#appraise(s1a)
#appraise(s1b)
#appraise(s1c)

my.rmse.gam(s1)
my.rmse.gam(s2)


```


```{r, include = F}
s2 <- gam(bai~s(BASAL_AREA_EQUIV.pl), data = bai.size, family = 'Gamma'(link = log))
anova.gam(s1, s2, test = 'F')
s2a <- gam(bai~s(BASAL_AREA_EQUIV.pl), data = bai.size, family = 'Gamma'(link = log))
plot.gam(s2)
plot.gam(s2a)

AIC(s2)
AIC(s2a)

plot.gam(s2)
plot.gam(s2a)

appraise(s2)
appraise(s2a)
```


```{r size with automatic selection, include=FALSE}


# shrinkage appraoch

gam1 <- gam(bai~s(DIAMETER, bs = 'ts') + s(HEIGHT, bs = 'ts') + s(treeba, bs = 'ts'), family = 'Gamma'(link = log), data = bai.size, na.action = 'na.omit')
summary.gam(gam1)
my.rmse.gam(gam1)

gam1a <- gam(bai~s(DIAMETER, bs = 'ts') + s(HEIGHT, bs = 'ts'), family = 'Gamma'(link = log), data = bai.size, na.action = 'na.omit')
summary.gam(gam1a)

gam1b <- gam(bai~s(DIAMETER, bs = 'ts') + s(HEIGHT, bs = 'ts') + s(treeba, bs = 'ts'), family = 'Gamma'(link = log), data = bai.size, na.action = 'na.omit')
gam1c <- gam(bai~s(DIAMETER, bs = 'tp') + s(HEIGHT, bs = 'tp') + s(treeba, bs = 'tp'), family = 'Gamma'(link = log), data = bai.size, na.action = 'na.omit')

summary.gam(gam1b)
summary.gam(gam1c)

draw(gam1)
draw(gam1a)
draw(gam1b)
draw(gam1c)

appraise(gam1)
appraise(gam1a)
appraise(gam1b)
appraise(gam1c)


my.rmse.gam(gam1)
my.rmse.gam(gam1a)
my.rmse.gam(gam1b)

```

```{r size p2, include = FALSE}
# double penalty

gam2 <- gam(bai~s(HEIGHT) + s(treeba) + s(CROWN_RATIO, k = 4), family = 'Gamma'(link = log), data = bai.size, na.action = 'na.omit', select = TRUE)
summary.gam(gam2)

gam2a <- gam(bai~s(DIAMETER) + s(HEIGHT) + s(treeba), family = 'Gamma'(link = log), data = bai.size, na.action = 'na.omit', select = TRUE)
summary.gam(gam2a)
#plot.gam(gam2)
draw(gam2a)
gam.check(gam2a)
my.rmse.gam(gam2a)


### Visit chunk above which applies the double penalty approach in concert with the shrinkage approach (see shrinkage above for example)
### Try out 'cs' - cubic spline - for shrinkage approach - see if effective degrees of freedom are modified in a favorable way. 
### Maybe look into using 'ad' which is an adaptive method. - not sure how this will work for either penalty approach
### Look into the method = 'REML' option. What does that mean? Does that change things favorable in either automatic approach. 

### once finished with those methods, try to use an interactive method. I will need to look into these. 
```

